\section{Introduction}\label{Introduction}

Traditionally, the capacity of a general purpose language can be extended to special domain by creating an embedded DSL (Domain-Specific Language) \cite{fowler2010domain} . For example, Akka provides a DSL to create finite-state machines \cite{lightbend2017akka}, which consists of some domain-specific operators including \lstinline{when}, \lstinline{goto}, \lstinline{stay}, etc. Although those operators looks similar to native control flow, they are not embeddable in native \lstinline{if}, \lstinline{while} or \lstinline{try} blocks, because the DSL code is split into small closures, preventing ordinary control flow from crossing the boundary of those closures. Thus, this kind of DSLs reinvent incompatible control flow to the meta-languages. TensorFlow's control flow operations \cite{abadi2016tensorflow} and Caolan's async library \cite{caolan2017async} are other examples of reinventing control flow in eDSLs.

Instead of reinventing the whole set of control flow for each DSL, a more general approach is designing a common protocol for control flow operators of all domains. In Haskell and other functional programming language, monads are used as the generic protocol of control flow operators \cite{wadler1990comprehending,wadler1992essence,jones1993composing}. Scala implementations of monads are provided by Scalaz \cite{kenji2017scalaz}, Cats \cite{typelevel2017cats}, Monix \cite{nedelcu2017monix} and Algebird \cite{twitter2016algebird}. A DSL author only has to implement \lstinline{bind} and \lstinline[language=Haskell,deletekeywords={return}]{return} operators in \lstinline{Monad} type class, and all the derived control flow operations like \lstinline{whileM} or \lstinline{ifM} are available. In addition, those monadic data type can be created and composed from \lstinline{do} notation \cite{jones1998haskell} or \lstinline{for} comprehension \cite{odersky2004scala}. For example, you can use the same \lstinline{scalaz.syntax} or \lstinline{for} comprehension to create random value generators \cite{nilsson2015scalacheck} and data-binding expressions \cite{yangbo2016binding}, as long as there are \lstinline{Monad} instances for data types \lstinline{org.scalacheck.Gen} and \lstinline{com.thoughtworks.binding.Binding} respectively.

An idea to avoid incompatible domain-specific control flow is converting direct style control flow to domain-specific control flow at compiler time. For example, Scala Async provides a macro to generate asynchronous control flow \cite{haller2013sip}, allowing normal sequential code inside a \lstinline{scala.async} block to run asynchronously. This approach can be generalized to any monadic data types. ThoughtWorks Each \cite{yangbo2015each}, Monadless \cite{flavio2017monadless}, effectful \cite{crockett2013effectful} and !-notation in Idris \cite{brady2013idris} are compiler-time transformers to convert source code of direct style control flow to monadic control flow. For example, with the help of ThoughtWorks Each, Binding.scala\cite{yangbo2016binding} can be used to create reactive HTML template from ordinary direct style code.

Another generic protocol of control flow is delimited continuation, which is known as the mother of all monads \cite{piponi2008mother}, where specific control flow in specific domain can be supported by specific answer types of continuations \cite{asai2007polymorphic}. Scala Continuations \cite{rompf2009implementing} and Stateless Future \cite{yangbo2014stateless} are two delimited continuation implementations in Scala. Both projects can convert direct style control flow to continuation-passing style closure chains at compiler time. For example, Stateless Future Akka \cite{yangbo2014statelessfutureakka}, based on Stateless Future, provides a special answer type for akka actors. Unlike reinvented control flow in \lstinline{akka.actor.AbstractFSM}, users can create complex finite-state machines from simple direct style control flow along with Stateless Future Akka's domain-specific operator \lstinline{nextMessage}.

All the previous approaches lack of the ability to collaborate with other DSLs. Each of the above DSLs can be exclusively enabled in a code block. Scala Continuations enables calls to \lstinline{@cps} method in \lstinline{reset} blocks, and ThoughtWorks Each enables the magic \lstinline{each} method \cite{yangbo2015each} for \lstinline{scalaz.Monad} in \lstinline{monadic} blocks. It was impossible to enable both DSL in one function.

Monad transformers \cite{liang1995monad} is a popular technique to solve the collaboration problem. The basic idea is to use a \lstinline{lift} function to convert different monadic type into the same transformed monadic type. Thus \lstinline{do} block of transformed monadic type can contain different DSL operations as long as they can be \lstinline{lift}ed. With the help of additional type classes, those \lstinline{lift} operations can be performed automatically.

However, deeply nested transformed monad was considered inefficient in  due to the nested \lstinline{lift}. An alternative approach proposed by
\cite{kiselyov2013extensible} is effect handlers. In effect handler approach, the DSL ``script'' is written in a universal monadic type \lstinline{Eff}, which allows multiple DSLs in one \lstinline{do} block. Each DSL is considered as an effect, which is dispatched by \lstinline{Eff} to the specific \lstinline{Handler}. This approach is heavy-weight, since only expressions written in \lstinline{Eff} script are able to use DSLs defined in effect handlers. Additional conversion is required to retrieve the ``raw'' data type from an \lstinline{Eff} \lstinline{do} block.

This paper proposed a new type class \lstinline{Dsl}, which can be consider as both the ad-hoc polymorphic version of delimited-continuation and a more generic version of \lstinline{Monad}. The Scala definition of the type class is shown in Listing~\ref{Dsl}.

\begin{lstlisting}[caption={The definition of \lstinline{Dsl} type class},label={Dsl}]
trait Dsl[Keyword, Domain, Value] {
  def apply(keyword: Keyword, handler: Value => Domain): Domain
}
\end{lstlisting}

Because \lstinline{Dsl} is more generic than \lstinline{Monad}, it allows a code block contain interleaved heterogeneous DSLs, which are called \lstinline{Keyword}s, interpreted by different \lstinline{Dsl} type class instances. Instead of returning an intermediate script type like \lstinline{Eff}, the return type of a DSL code block can vary as long as it supports operations used in it. No intermediate \lstinline{Monad} for dispatching is used. The difference of architecture between effect handler approach and our approach is shown in Figure~\ref{eff-architecture} and Figure~\ref{dsl-architecture}.

\begin{figure}[h t b p]
  \begin{dot2tex}[dot,mathmode,autosize,graphstyle={scale=0.78,transform shape}]
  digraph {
  	rankdir=LR
    shape=rect

  	subgraph cluster_code_block {
      graph [ label="\textrm{a code block that returns an \lstinline{Eff}}" ]
      
      Effect_0
      Effect_1
      Effect_2
      Effect_dots [ label="{\vdots}" shape=none ]
      Effect_n
    }
    
    Effect_0 -> "Eff"  [ label="\textrm{interpreted by}" ]
    "Eff" -> Handler_0 [ label="\textrm{dispatched to}" ]
    Effect_1 -> "Eff"  [ label="\textrm{interpreted by}" ]
    "Eff" -> Handler_1 [ label="\textrm{dispatched to}" ]
    Effect_2 -> "Eff"  [ label="\textrm{interpreted by}" ]
    "Eff" -> Handler_2 [ label="\textrm{dispatched to}" ]
    Handler_dots  [ label="{\vdots}" shape=none ]
    Effect_dots -> "Eff"  [ style=invis ]
    "Eff" -> Handler_dots [ style=invis ]
    Effect_n -> "Eff"  [ label="\textrm{interpreted by}" ]
    "Eff" -> Handler_n [ label="\textrm{dispatched to}" ]
  }
  \end{dot2tex}

  \caption{The architecture of \lstinline{Eff} approach}
  \label{eff-architecture}
\end{figure}

\begin{figure}[h t b p]
  \begin{dot2tex}[dot,mathmode,autosize,graphstyle={transform shape}]
  digraph {
  	rankdir=LR
    shape=rect

  	subgraph cluster_code_block {
      graph [ label="\textrm{a code block that returns any \texttt{Domain}}" ]
      Keyword_0
      Keyword_1
      Keyword_2
      Keyword_dots [ label="{\vdots}" shape=none ]
      Keyword_n
    }

    Keyword_0 -> Dsl_0 [ label="\textrm{interpreted by}" ]
    Keyword_1 -> Dsl_1 [ label="\textrm{interpreted by}" ]
    Keyword_2 -> Dsl_2 [ label="\textrm{interpreted by}" ]
    Keyword_dots -> Dsl_dots [ style=invis ]
    Keyword_n -> Dsl_n [ label="\textrm{interpreted by}" ]

    Dsl_dots [ label="{\vdots}" shape=none ]
  }
  \end{dot2tex}

  \caption{The architecture of \lstinline{Dsl} approach}
  \label{dsl-architecture}
\end{figure}

Ordinary delimited continuations \cite{Danvy89afunctional} can be defined as a function to register a callback function (Listing~\ref{Continuation}), which is similar to the signature of \lstinline{Dsl} type class.

\begin{lstlisting}[caption={The definition of a delimited continuation},label={Continuation}]
type Continuation[Domain, Value] = (Value => Domain) => Domain
\end{lstlisting}

A \lstinline{Continuation} itself contains the implementation of an operation. As a result, a delimited continuation can only be used in a function that returns the specified \lstinline{Domain}. Unlike ordinary \lstinline{Continuation}s, in our approach, each operation is ad-hoc polymorphic to the \lstinline{Domain}, thus the it is can be interpreted differently according to the enclosing \lstinline{Domain}, as shown in Figure~\ref{dsl-architecture}.

In the rest sections of this paper, we will present the design and use cases of \lstinline{Dsl} type class, including:

\begin{enumerate}
  \item Simulating some first-class features in Python, C\#, ECMAScript and C++, as library-defined keywords;
  \label{simulating-first-class-features}

  \item Simulating \lstinline{Monad} to create imperative code blocks;
  \label{simulating-monad}

  \item Composing delimited continuations with less closure creation than \lstinline{Continuation} \lstinline{Monad} approach;
  \label{composing-delimited-continuations}

  \item Making \lstinline{Continuation} stack safe, in a non-intrusive approach;
  \label{stack-safe-Continuation}

  \item Using any combination of the features (\ref{simulating-monad}), (\ref{composing-delimited-continuations}), (\ref{stack-safe-Continuation}), and (\ref{simulating-first-class-features}), in a single code block.
\end{enumerate}

All code examples except Section~\ref{Haskell implementation} are written in our Scala library \textit{Dsl.scala}, which provides an implementation of \lstinline{Dsl} type class, along with a Scala compiler plug-in to perform CPS-transformation for types that has corresponding \lstinline{Dsl} type class. The compiler plug-in avoids ``callback hell'' problem, allowing a more general version of Idris-like !-notation \cite{brady2013idris} direct style DSL, which can be used for not only monadic data type but also other operations.

% TODO:

% \textit{Dsl.scala} allows library authors to create special keywords for language features that were usually implemented by the compiler. Those library-defined keywords (LDKs) are adaptive to the enclosing DSL, as a library user can create one function that contains interleaved LDKs from different vendors, along with ordinary Scala control flow. Unlike \lstinline{Eff}, an LDK is non-intrusive, can be added into an existing function as an optional first-class feature.

% \textit{Dsl.scala} ships with some built-in LDKs, including:
% \begin{itemize}
%   \item The \lstinline{Shift} LDK for asynchronous programming, similar to the \lstinline[language=Python,style=Python3]{await} and \lstinline[language=Python,style=Python3]{async} keywords in C\#, Python and JavaScript.
%   \item The \lstinline{Yield} LDK for generating lazy streams, similar to the \lstinline[language=Python,style=Python3]{yield} keyword in C\#, Python and JavaScript.
%   \item The \lstinline{Each} LDK for traversing each element of a collection, similar to \lstinline{for}, \lstinline{yield} keywords for Scala collections.
%   \item The \lstinline{Fork} LDK for duplicating current thread, similar to the \lstinline{fork} system call in POSIX.
%   \item The \lstinline{AutoClose} LDK to automatically close resources when exiting a scope, similar to the destructor feature in C++.
%   \item The \lstinline{Monadic} LDK for creating Scalaz \cite{kenji2017scalaz} or Cats \cite{typelevel2017cats} monadic control flow, similar to the !-notation in Idris\cite{brady2013idris}.
% \end{itemize}

\section{From delimited continuation to \lstinline{Dsl} type class}\label{Basic concepts}

Our goal is making the control flow of a programming language be extensible. In this section, we will introducing the \lstinline{Dsl} type class and the concept of name-based CPS transformation from the process of porting some first class Python language features to Scala, as library-defined keyword (LDK) \footnote{Code listings shown in Section~\ref{Basic concepts} are not exactly the same as the implementation in \textit{Dsl.scala}, instead, these implementations of LDKs are modified or simplified for the purpose of introducing the concept of the LDK approach more clearly.}. The term LDK denotes language features implemented by libraries, in the approach introduced in this paper. No metaprogramming knowledge is required for either LDK authors or LDK users \footnote{ Though, Scala LDKs need the common compiler plug-ins to perform CPS transformation and Haskell LDKs need \lstinline{RebindableSyntax} described in Section~\ref{Haskell implementation}}. But, in other languages, they used to be implemented as  compiler built-in first-class features.

The rest parts of this section is organized as following. Firstly, in Section~\ref{Implementing LDKs as ordinary delimited continuations} and Section~\ref{CPS transformation}, we will present how to \lstinline{yield} to Scala in the ordinary delimited continuation approach. Then in Section~\ref{Monadic blocks}, we will present how to port \lstinline{await} to Scala in a Monad-like interface. Finally, in Section~\ref{Collaborative library-defined keywords} and Section~\ref{Adaptive library-defined keywords}, we will introduce the type class \lstinline{Dsl} type class to unifying all the previous approaches, and in addition, allowing using multiple LDKs like \lstinline{yield} and \lstinline{await} together.

\subsection{Implementing LDKs as ordinary delimited continuations}\label{Implementing LDKs as ordinary delimited continuations}

For example, given generator is a language feature available in Python, ECMAScript, C\# and many other languages, we will demonstrate how to port the feature to Scala, with the help of the \textit{Dsl.scala} library, and still keeping the compatibility with Scala native control flow and type system.

In Python, ECMAScript, and C\#, a generator is a function that returns an \lstinline{Iterator} or an \lstinline{IEnumerator}. The \lstinline{yield} keyword is available inside the generator, to lazily produce one element, which can be consumed by the \lstinline{Iterator} / \lstinline{IEnumerator} user. Listing~\ref{xorShiftRandomGenerator-Python} is an example to create an Xorshift \cite{marsaglia2003xorshift} pseudo-random number generator that returns an infinite iterator of generated numbers. Note that NumPy \footnote{http://www.numpy.org/} is used for 32-bit integers, and type hinting \footnote{https://docs.python.org/3/library/typing.html} is used for clarity.

\begin{lstlisting}[language=Python,style=Python3,caption={An Xorshift pseudo-random number generator in Python 3.5+},label={xorShiftRandomGenerator-Python}]
def xor_shift_random_generator(seed: np.uint32) -> Iterator[np.uint32]:
  tmp1 = np.uint32(seed ^ (seed << 13))
  tmp2 = np.uint32(tmp1 ^ (tmp1 >> 17))
  tmp3 = np.uint32(tmp2 ^ (tmp2 << 5))
  yield tmp3
  yield from xor_shift_random_generator(tmp3)

generated_numbers = xor_shift_random_generator(seed = np.uint32(2463534242))

print(generated_numbers.__next__()) // The first generated random number
print(generated_numbers.__next__()) // The second generated random number
\end{lstlisting}

In our LDK-based generator, the return type is replaced to \lstinline{Stream}, which can be considered as the immutable version of \lstinline{Iterator}, and the compiler-defined keyword \lstinline{yield} is replaced to library-defined keyword \lstinline{Yield}. Listing~\ref{xorShiftRandomGenerator} is an example to create an Xorshift \cite{marsaglia2003xorshift} pseudo-random number generator that returns an infinite stream of generated numbers. 

\lstinline{xorShiftRandomGenerator} does not throw a \lstinline{StackOverflowError}, because the execution of \lstinline{xorShiftRandomGenerator} will be paused at \lstinline{Yield}, and it will be resumed when the caller is looking for the next number.

\begin{lstlisting}[caption={An Xorshift pseudo-random number generator with the help of the LDK \lstinline{Yield}},label={xorShiftRandomGenerator}]
def xorShiftRandomGenerator(seed: Int): Stream[Int] = {
  val tmp1 = seed ^ (seed << 13)
  val tmp2 = tmp1 ^ (tmp1 >>> 17)
  val tmp3 = tmp2 ^ (tmp2 << 5)
  Yield(tmp3) { _: Unit =>
    xorShiftRandomGenerator(tmp3)
  }
}

val generatedNumbers = xorShiftRandomGenerator(seed = 2463534242)

println(generatedNumbers(0)) // The first generated random number
println(generatedNumbers(1)) // The second generated random number
\end{lstlisting}

Despite of the implementation of \lstinline{Yield}, which will be revealed in incoming sections, the above use case demonstrates some basic concepts when using \lstinline{Dsl} type class:

\begin{enumerate}
  \item \lstinline{xorShiftRandomGenerator}, and any functions that contains nested continuation-passing style (CPS) calls, are considered as written in some kind of embedded Domain-Specific Languages (eDSL).
  \item The word ``domain'' in the term ``Domain-Specific Language'' stands for the return type of the enclosing function. For example, \lstinline{Stream[Int]} is the domain of \lstinline{xorShiftRandomGenerator}.
  \item The domain-specific language used by the enclosing function consists of some domain-specific ``library-defined keywords'' (LDK). For example, \lstinline{Yield} is an LDK available for \lstinline{Stream} domains.
  \item Along with LDK, DSLs written in \textit{Dsl.scala} also support native Scala control flows and expressions.
\end{enumerate}

For simple use case such as \lstinline{xorShiftRandomGenerator}, LDKs can be implemented as ordinary delimited continuations. Listing~\ref{NonadaptiveYield} shows an implementation of the \lstinline{Yield} LDK, as a delimited continuation, in which the \lstinline{Yield} LDK creates infinite \lstinline{Stream}s by capturing \lstinline{handler} into a lazily evaluated \lstinline{Stream.Cons}.

\begin{lstlisting}[caption={Implementing \lstinline{Yield} LDK as ordinary delimited continuations},label={NonadaptiveYield}]
case class Yield[A](element: A) extends Continuation[Stream[A], Unit] {
  def apply(handler: Unit => Stream[A]): Stream[A] = {
    new Stream.Cons(element, handler(()))
  }
}
\end{lstlisting}

\subsection{Auto-\lstinline{reset} name-based CPS transformation}\label{CPS transformation}

The syntax of Listing~\ref{xorShiftRandomGenerator} differs from first-class generators in Python, ECMAScript, and C\#, as the code block contains some manually created CPS closures. Ideally, the ``rest'' program after a \lstinline{Yield} operation should be indented at the same level of \lstinline{Yield}, not in a nested closure. This coding style can be achieved by the !-notation provided by \textit{Dsl.scala}'s built-in compiler plug-ins. The function \lstinline{xorShiftRandomGenerator} can be written as Listing~\ref{xorShiftRandomGenerator-bang} with the help of the !-notation plug-ins.

\begin{lstlisting}[caption={TheXorshift pseudo-random number generator,  in the style of !-notation},label={xorShiftRandomGenerator-bang}]
def xorShiftRandomGenerator(seed: Int): Stream[Int] = {
  val tmp1 = seed ^ (seed << 13)
  val tmp2 = tmp1 ^ (tmp1 >>> 17)
  val tmp3 = tmp2 ^ (tmp2 << 5)
  !Yield(tmp3)
  xorShiftRandomGenerator(tmp3)
}
\end{lstlisting}

Our compiler plug-ins performs CPS-transform in a similar approach to \lstinline{reset}/\lstinline{shift} control operators in Scala Continuations \cite{rompf2009implementing}. The \lstinline{!} prefix corresponds to the \lstinline{shift} control operator, and the \lstinline{reset} control operator is added to every function or method body implicitly. Thus the above \lstinline{xorShiftRandomGenerator} is equivalent to Listing~\ref{xorShiftRandomGenerator-scala-continuations} in Scala Continuations.

\begin{lstlisting}[caption={TheXorshift pseudo-random number generator,  in Scala Continuations},label={xorShiftRandomGenerator-scala-continuations}]
def xorShiftRandomGenerator(seed: Int): Stream[Int] = reset {
  val tmp1 = seed ^ (seed << 13)
  val tmp2 = tmp1 ^ (tmp1 >>> 17)
  val tmp3 = tmp2 ^ (tmp2 << 5)
  shift(Yield(tmp3))
  xorShiftRandomGenerator(tmp3)
}
\end{lstlisting}

Because of the implicitly added \lstinline{reset} control operator, the boundary of a delimited continuation can never be escaped from a function in our approach. As a result, our plug-ins are able to eliminate the internal context of delimited continuations. \lstinline{ControlContext} or \lstinline{cps} type annotation in Scala Continuations are not necessary any more.

There is another difference between our compiler plug-ins and Scala Continuation. Our compiler plug-ins are name-based instead of type-based, allowing CPS-transformation in monadic blocks, which will be discussed in next section.

\subsection{Monadic blocks}\label{Monadic blocks}

In previous sections, we have demonstrated how to port the compiler-defined keyword \lstinline{yield} to Scala, as a library-defined keyword. In this section, we will demonstrate how to import another compiler-defined keyword, \lstinline{await}, to Scala, as a library-defined keyword.

\lstinline{await} is available in Python, ECMAScript, or C\#, to compose multiple asynchronous tasks into one task. For example, the compiler-defined keyword \lstinline{await} in Python is available in functions marked as \lstinline{async} that returns an \lstinline{Awaitable}. Each \lstinline{await} pauses the execution until the asynchronous operation is complete. An example of creating an \lstinline{Awaitable} to download two web pages by aiohttp \footnote{https://docs.aiohttp.org/} is shown in Listing~\ref{download_two_pages-Python}.

\begin{lstlisting}[language=Python,style=Python3,caption={Asynchronously downloading two web pages in Python},label={download_two_pages-Python}]
async def download_two_pages() -> Awaitable[Tuple[bytes, bytes]]:
  session = aiohttp.ClientSession()
  response1 = await session.get('http://example.com')
  content1 = await response1.read()
  response2 = await session.get('http://example.net')
  content2 = await response2.read()
  return (content1, content2)
\end{lstlisting}

When porting \lstinline{await} feature to Scala, we replace the compiler-defined keyword \lstinline{await} to a library-defined keyword \lstinline{Await}, and \lstinline{Awaitable} to \lstinline{Future} \footnote{https://docs.scala-lang.org/overviews/core/futures.html} as shown in Listing~\ref{downloadTowPages}, where \lstinline{ByteString}, \lstinline{Http}, \lstinline{Http}, \lstinline{HttpMethods}, \lstinline{HttpRequest} in the example are asynchronous HTTP library provided by Akka \footnote{https://akka.io/} and Akka HTTP \footnote{https://akka.io/akka-http/}.

\begin{lstlisting}[caption={Asynchronously downloading two web pages in \textit{Dsl.scala} },label={downloadTowPages}]
def downloadTwoPages(): Future[(ByteString, ByteString)] = {
  Await(Http().singleRequest(HttpRequest(HttpMethods.GET, "http://example.com"))) { response1 =>
    Await(response1.entity.toStrict(timeout = 5.seconds)) { content1 =>
      Await(Http().singleRequest(HttpRequest(HttpMethods.GET, "http://example.net"))) { response2 =>
        Await(response2.entity.toStrict(timeout = 5.seconds)) { content2 =>
          Future((content1.data, content2.data))
        }
      }
    }
  }
}
\end{lstlisting}

\lstinline{Await} should accept a \lstinline{handler} to handle the incoming value in an asynchronous \lstinline{Future}, and it can be implemented as a forwarder of \lstinline{flatMap} on \lstinline{Future}, as shown in Listing~\ref{NonadaptiveAwait}.

\begin{lstlisting}[caption={Implementing \lstinline{Await} LDK as a forwarder to \lstinline{flatMap}},label={NonadaptiveAwait}]
case class Await[A](future: Future[A]) {
  def apply[B](handler: A => Future[B])(implicit ec: ExecutionContext): Future[B] = {
      future.flatMap(handler)
  }
}
\end{lstlisting}

Similar to CPS-transformation in Listing~\ref{xorShiftRandomGenerator-bang}, the nested callback functions registered to \lstinline{Await} in the \lstinline{downloadTowPages} method can be replaced to !-notation with the help of our compiler plug-ins. The transformed version of \lstinline{downloadTowPages} is shown in Listing~\ref{downloadTowPages-bang}.

\begin{lstlisting}[caption={Asynchronously downloading two web pages, in the style of !-notation},label={downloadTowPages-bang}]
def downloadTwoPages(): Future[(ByteString, ByteString)] = {
  val response1 = !Await(Http().singleRequest(HttpRequest(HttpMethods.GET, "http://example.com"))) 
  val content1 = !Await(response1.entity.toStrict(timeout = 5.seconds))
  val response2 = !Await(Http().singleRequest(HttpRequest(HttpMethods.GET, "http://example.net")))
  val content2 = !Await(response2.entity.toStrict(timeout = 5.seconds))
  Future((content1.data, content2.data))
}
\end{lstlisting}

Alternately, the last \lstinline{Future} call can be moved to the front of the function body as shown in Listing~\ref{downloadTowPages-bang-block}. It is possible because the block statement in Scala is also an expression that has a value. \lstinline|{e1; e2; f(a)}| and \lstinline|f{e1; e2; a}| are always equivalent as long as \lstinline{f} is a call-by-value function.

\begin{lstlisting}[caption={Asynchronously downloading two web pages, within a \lstinline{Future} block},label={downloadTowPages-bang-block}]
def downloadTwoPages() = Future {
  val response1 = !Await(Http().singleRequest(HttpRequest(HttpMethods.GET, "http://example.com"))) 
  val content1 = !Await(response1.entity.toStrict(timeout = 5.seconds))
  val response2 = !Await(Http().singleRequest(HttpRequest(HttpMethods.GET, "http://example.net")))
  val content2 = !Await(response2.entity.toStrict(timeout = 5.seconds))
  (content1.data, content2.data)
}
\end{lstlisting}

Note that both Listing~\ref{downloadTowPages-bang} and Listing~\ref{downloadTowPages-bang-block} are unable to be expressed in Scala Continuation because the \lstinline{shift} control operator accepts only \lstinline{Continuation}, while the signature of \lstinline{flatMap} differs from \lstinline{Continuation}, due to the additional type parameter \lstinline{B} and the additional implicit parameter of \lstinline{ExecutionContext}.

Fortunately our CPS-transformation compiler plug-ins are name-based. Given any expression $e_0$, $e_1$, ..., $e_n$, variable name $v_0$, $v_1$, ..., $v_n$ and the final expression $r$ in a function \lstinline{f}, as shown in Listing~\ref{bang-block}, it will be converted to Listing~\ref{cps-block} by our compiler plug-ins. The plug-ins converts \lstinline{!} prefixes to callback functions registrations, regardless what the signature of \lstinline{apply} is. Both delimited continuation \lstinline{Continuation} and monad-like operations are supported. The behavior of our CPS-transformation compiler plug-ins is similar to !-notation in Idris or do-notation with \lstinline{RebindableSyntax} in Haskell.

\begin{lstlisting}[mathescape=true, caption={A function with !-notation}, label={bang-block}]
def f = {
  val $v_0$ = !$e_0$;
  val $v_1$ = !$e_1$;
  $\hdots$
  val $v_n$ = !$e_n$;
  $r$;
}
\end{lstlisting}

\begin{lstlisting}[mathescape=true,caption={The code converted from !-notation by our name-based CPS-transformation plug-ins}, label={cps-block}]
def f = {
  $e_0$ { $v_0$ =>
    $e_1$ { $v_1$ =>
      $\hdots$
      $e_n$ { $v_n$ =>
        $r$
      }
    }
  }
}
\end{lstlisting}

While \lstinline{Await} implemented in Listing~\ref{NonadaptiveAwait} can ``extract'' the value of a \lstinline{Future}, it can be generalized to any \lstinline{Monad}s as shown in Listing~\ref{NonadaptiveMonadic}.

\begin{lstlisting}[caption={Implementing \lstinline{Monadic} LDK as a forwarder to \lstinline{Monad}},label={NonadaptiveMonadic}]
trait Monad[F[_]] {
  def bind[A, B](fa: F[A])(f: A => F[B])
  def point[A](a: A): F[A]
}
object Monad {
  implicit def futureMonad(implicit ec: ExecutionContext) = new Monad[Future] {
    def bind[A, B](fa: Future[A])(f: A => Future[B]) = fa.flatMap(f)
    def point[A](a: A): Future[A] = Future(a)
  }
}

case class Monadic[F[_], A](fa: F[A]) {
  def apply[B](handler: A => F[B])(implicit monad: Monad[F]): F[B] = {
    monad.bind(fa)(handler)
  }
}
\end{lstlisting}

\lstinline{Monadic} is an more generic LDK than \lstinline{Await}, able to ``extract'' any monadic value, not only future, as long as the corresponding \lstinline{Monad} type class instance exists.

\subsection{Collaborative library-defined keywords}\label{Collaborative library-defined keywords}

By now, we ported Python's compiler-defined keywords \lstinline{yield} and \lstinline{await} to Scala, as library-defined keywords. However, those keywords are not collaborative. LDK \lstinline{Yield} and \lstinline{Await} implemented in previous sections cannot be present in one function, while Python 3.5 allows using \lstinline{yield} and \lstinline{await} together to create asynchronous generators.

In this section, we will present a use case of Python's \lstinline{yield} and \lstinline{await} in one function, and then modify the previous implementation of LDK \lstinline{Yield} and \lstinline{Await} to gain the ability of collaboration.

\begin{lstlisting}[language=Python,style=Python3,caption={Downloading two web pages as an asynchronous generator in Python},label={download_two_pages_generator-Python}]
async def download_two_pages_generator() -> AsyncGenerator[bytes, None]:
    session = aiohttp.ClientSession()
    response1 = await session.get('http://example.com')
    content1 = await response1.read()
    yield content1
    response2 = await session.get('http://example.net')
    content2 = await response2.read()
    yield content2
\end{lstlisting}

Listing~\ref{download_two_pages_generator-Python} shows an example of downloading two web pages by mix of \lstinline{yield} and \lstinline[language=Python,style=Python3]{await}. In Python, when a an \lstinline{async} function like \lstinline{download_two_pages_generator} contains both \lstinline{yield} and \lstinline{await} keywords, the return type becomes \lstinline{AsyncGenerator}.

The corresponding type of \lstinline{AsyncGenerator[bytes, None]} in Scala could be \lstinline{Stream[Future[ByteString]]}, which should be the return type of \lstinline{apply} in the modified version of \lstinline{Yield} and \lstinline{Await}. Therefore, the modified version of \lstinline{Yield} and \lstinline{Await} can be implemented as Listing~\ref{Yield-StreamFuture} and Listing~\ref{Await-StreamFuture} , and the usage of asynchronous generator with !-notation is shown in Listing~\ref{downloadTwoPages-StreamFuture}.

\begin{lstlisting}[caption={Implementing modified version of \lstinline{Yield} LDK for creating asynchronous generators},label={Yield-StreamFuture}]
case class Yield[A](element: A) {
  def apply(handler: Unit => Stream[Future[A]])(implicit ec: ExecutionContext): Stream[Future[A]] = {
    new Stream.Cons(Future(element), handler(()))
  }
}
\end{lstlisting}

\begin{lstlisting}[caption={Implementing modified version of \lstinline{Await} LDK for creating asynchronous generators},label={Await-StreamFuture}]
case class Await[A](future: Future[A]) {
  def apply[B](handler: A => Stream[Future[B]])(implicit ec: ExecutionContext): Stream[Future[B]] = {
    val ff = future.map(handler)
    new Stream.Cons(ff.flatMap(_.head), result(ff, Duration.Inf).tail)
  }
}
\end{lstlisting}
  

\begin{lstlisting}[caption={Downloading two web pages as an asynchronous generator, in the style of !-notation},label={downloadTwoPages-StreamFuture}]
def downloadTwoPagesGenerator(): Stream[Future[ByteString]] = {
  // The following Await and Yield LDKs will create a Future to download the page at example.com, as the first element of the output Stream
  val response1 = !Await(Http().singleRequest(HttpRequest(HttpMethods.GET, "http://example.com")))
  val content1 = !Await(response1.entity.toStrict(timeout = 5.seconds))
  !Yield(content1.data)

  // The following Await and Yield LDKs will create a Future to download the page at example.net, as the second element of the output Stream
  val response2 = !Await(Http().singleRequest(HttpRequest(HttpMethods.GET, "http://example.net")))
  val content2 = !Await(response2.entity.toStrict(timeout = 5.seconds))
  !Yield(content2.data)

  // Remaining elements after yielded futures
  Stream.empty[Future[ByteString]]
}
\end{lstlisting}

Semantically, each \lstinline{Yield} LDK ``prepend'' a value at the head of the output \lstinline{Stream}, and the remaining parts of the output \lstinline{Stream} is a \lstinline{Stream.empty}. Any asynchronous \lstinline{Await} operations performed before a \lstinline{Yield} are collected as the asynchronous \lstinline{Future} for the yielded element.

The modified version of \lstinline{Yield} and \lstinline{Await} LDKs are collaborative, as they are both available for the domain of \lstinline{Stream[Future[ByteString]]}, thus they can be used together in one function.

\subsection{Adaptive library-defined keywords}\label{Adaptive library-defined keywords}

In previous sections, we had presented two different implementations of \lstinline{Yield} in Listing~\ref{NonadaptiveYield} and Listing~\ref{Yield-StreamFuture} for creating generators and asynchronous generators, respectively, and two different implementation of \lstinline{Await} in Listing~\ref{NonadaptiveAwait} and Listing~\ref{Await-StreamFuture} for creating asynchronous value and asynchronous generators, respectively. However, compiler-defined keywords \lstinline{await} and \lstinline{yield} in Python are adaptive to their context, available in either cases. In this section, we will introduce the type class \lstinline{Dsl} for creating adaptive library-defined keywords as well.

The \lstinline{Dsl} type class as defined in Listing~\ref{Dsl} is usually used along with \lstinline{Keyword} (Listing~\ref{Keyword}), which should be the super type of all adaptive LDKs.

\begin{lstlisting}[caption={\lstinline{Keyword}, the super type of all adaptive LDKs},label={Keyword}]
trait Keyword[Self, Value] { this: Self =>
  def apply[Domain](handler: Value => Domain)(implicit dsl: Dsl[Self, Domain, Value]): Domain = {
    dsl.apply(this, handler)
  }
}
\end{lstlisting}

Every \lstinline{apply} call registers a callback to handle the \lstinline{Value}, and finally returns a \lstinline{Domain}. The keyword's self type (\lstinline{Self}) and the value of the keyword (\lstinline{Value}), defined in sub types of \lstinline{Keyword}. The actually implementation of the keyword varies according to the return type of enclosing function (\lstinline{Domain}), is resolved by the multi-parameter type class \lstinline{Dsl}. For example, the adaptive version of \lstinline{Yield} and \lstinline{Await} can be defined as Listing~\ref{Yield} and Listing~\ref{Await}.

\begin{lstlisting}[caption={The \lstinline{Yield} LDK, the adaptive version},label={Yield}]
case class Yield[A](element: A) extends Keyword[Yield[A], Unit]
\end{lstlisting}

\begin{lstlisting}[caption={The \lstinline{Await} LDK, the adaptive version},label={Await}]
case class Await[Value](future: Future[Value]) extends Keyword[Await[Value], Value]
\end{lstlisting}

When performing !-notation on a \lstinline{Keyword} to produce a \lstinline{Value} inside a function whose return type is \lstinline{Domain}, the type class instance of \lstinline{Dsl[Keyword, Domain, Value]} is required. For example, Adaptive version of LDKs in Listing~\ref{NonadaptiveYield},  Listing~\ref{NonadaptiveAwait},  Listing~\ref{Yield-StreamFuture} and Listing~\ref{Await-StreamFuture} requires \lstinline{Dsl} instances implemented in Listing~\ref{Yield-generator-instance}, Listing~\ref{Yield-async-generator-instance}, Listing~\ref{Await-future-instance} and Listing~\ref{Await-async-generator-instance}.

\begin{lstlisting}[caption={The \lstinline{Dsl} type class instance of \lstinline{Yield} for creating generators},label={Yield-generator-instance}]
implicit def yieldDsl[A, B >: A]: Dsl[Yield[A], Stream[B], Unit] =
  new Dsl[Yield[A], Stream[B], Unit] {
    def apply(keyword: Yield[A], mapper: Unit => Stream[B]): Stream[B] = {
      new Stream.Cons(keyword.element, mapper(()))
    }
  }
\end{lstlisting}

\begin{lstlisting}[caption={The \lstinline{Dsl} type class instance of \lstinline{Yield} for creating asynchronous generators},label={Yield-async-generator-instance}]
implicit def futureYieldDsl[A, B >: A]: Dsl[Yield[A], Stream[Future[B]], Unit] =
  new Dsl[Yield[A], Stream[Future[B]], Unit] {
    def apply(keyword: Yield[A], handler: Unit => Stream[Future[B]]): Stream[Future[B]] = {
      new Stream.Cons(Future.successful(keyword.element), handler(()))
    }
  }
\end{lstlisting}

\begin{lstlisting}[caption={The \lstinline{Dsl} type class instance of \lstinline{Await} for creating asynchronous values},label={Await-future-instance}]
implicit def awaitDsl[A, B](implicit ec: ExecutionContext): Dsl[Await[A], Future[B], A] =
  new Dsl[Await[A], Future[B], A] {
    def apply(keyword: Await[A], handler: A => Future[B]): Future[B] = {
      keyword.future.flatMap(handler)
    }
  }
\end{lstlisting}

\begin{lstlisting}[caption={The \lstinline{Dsl} type class instance of \lstinline{Await} for creating asynchronous generators},label={Await-async-generator-instance}]
implicit def streamAwaitDsl[A, B](implicit ec: ExecutionContext): Dsl[Await[A], Stream[Future[B]], A] =
  new Dsl[Await[A], Stream[Future[B]], A] {
    def apply(keyword: Await[A], handler: A => Stream[Future[B]]): Stream[Future[B]] = {
      val ff = keyword.future.map(handler)
      new Stream.Cons(ff.flatMap(_.head), result(ff, Duration.Inf).tail)
    }
  }
\end{lstlisting}

By introducing the type class \lstinline{Dsl}, the \lstinline{apply} calls to \lstinline{Keyword} are ad-hoc polymorphic to the specific domain of the call site. As a result, keywords like \lstinline{Yield} and \lstinline{Await} becomes adaptive.

\section{Implementation}\label{Implementation}

We implemented the LDK approach in the framework \textit{Dsl.scala}, which consists with the following parts:

\begin{description}
  \item[The core library] contains the definition of the \lstinline{Dsl} type class and \lstinline{Keyword}, the common super type of LDKs. They are slightly different from the definition in Listing~\ref{Dsl} and Listing~\ref{Keyword}:
  \begin{itemize}
    \item The \lstinline{apply} method in \lstinline{Dsl} and \lstinline{Keyword} is renamed to \lstinline{cpsApply} in case of name clash, considering the method name \lstinline{apply} has been widely used in existing Scala libraries.
    \item There is an additional dummy method \lstinline{unary_!} annotated as \lstinline{@shift} defined in \lstinline{Keyword}. The \lstinline{unary_!} method (or any other \lstinline{@shift}-annotated methods) will be specially treated by our compiler plug-ins, thought it will be considered as an ordinary method from the point view of type checker when our compiler plug-ins is not enabled. The definition of \lstinline{unary_!} method is especially useful for IntelliJ IDEA\footnote{https://www.jetbrains.com/idea/}'s built-in type checker, preventing the edit window in the IDE from being red marked.
    \item \lstinline{Keyword} is a universal trait \footnote{https://docs.scala-lang.org/overviews/core/value-classes.html}, allowing its subtypes to be value classes, which involves lower memory overhead in most of LDK use cases.
  \end{itemize}
  \item[Compiler plug-ins] performs CPS-transformation as described in Section~\ref{CPS transformation}. There are two compiler plug-ins in \textit{Dsl.scala}: \lstinline{ResetEverywhere} and \lstinline{BangNotation}. The \lstinline{ResetEverywhere} plug-in adds a hidden \lstinline{@reset} annotation to the block of every method in source code, and the \lstinline{BangNotation} plug-in perform CPS-transformation according to the \lstinline{unary_!} method (or any method annotated as \lstinline{@shift}) and \lstinline{@reset} annotation, which are equivalent to \lstinline{shift} and \lstinline{reset} control operators, respectively, described by \cite{Danvy89afunctional}.

  In addition to block expressions mentioned in Listing~\ref{cps-block}, all other first-class control flows in Scala are transformed to CPS form by the \lstinline{BangNotation} plug-in \footnote{Note that the \lstinline{for} expression is not converted as it is not a first-class control flow but a group of nested method calls.}.

  Unlike other typed delimited continuation implementations, the \lstinline{BangNotation} plug-in performs name-based CPS-transformation. Each !-notation in a transformed function can be converted to an arbitrary \lstinline{cpsApply} method call as long as it accepts a callback function parameter. Type checking for the transformed function will be performed once the transformation is done.

  Although the \lstinline{Dsl} type class does not allow changing the domain of a DSL code block, the \lstinline{BangNotation} plug-in itself allows domain changing when the \lstinline{cpsApply} method is implemented without \lstinline{Dsl} type class. Thus, the \lstinline{printf} problem can be trivially resolved by our compiler plug-ins as described in Section~\ref{resolve-printf-problem}.
  \item[Built-in library-defined keywords] are shipped with \textit{Dsl.scala}, to provide many language features that are not available natively in Scala, including:
  \begin{itemize}
    \item The \lstinline{Await} LDK for asynchronous programming with Scala \lstinline{Future}, similar to the \lstinline[language=Python,style=Python3]{await} and \lstinline[language=Python,style=Python3]{async} keywords in C\#, Python and JavaScript.
    \item The \lstinline{Shift} LDK for asynchronous programming with delimited continuations, similar to the \lstinline{shift} operator in Scala Continuations.
    \item The \lstinline{AsynchronousIo} LDKs for perform I/O on an asynchronous channel.
    \item The \lstinline{Yield} LDK for generating lazy streams, similar to the \lstinline[language=Python,style=Python3]{yield} keyword in C\#, Python and JavaScript.
    \item The \lstinline{Each} LDK for traversing each element of a collection, similar to \lstinline{for}, \lstinline{yield} keywords for Scala collections.
    \item The \lstinline{Continue} LDK to skip an element in a LDK-based collection comprehension, similar to \lstinline{continue} keyword in many languages.
    \item The \lstinline{Fork} LDK for duplicating current thread, similar to the \lstinline{fork} system call in POSIX.
    \item The \lstinline{AutoClose} LDK to automatically close resources when exiting a scope, similar to the destructor feature in C++.
    \item The \lstinline{Monadic} LDK for creating Scalaz \cite{kenji2017scalaz} or Cats \cite{typelevel2017cats} monadic control flow, similar to the !-notation in Idris\cite{brady2013idris}.
  \end{itemize}
  \item[Asynchronous task utilities] contains a \lstinline{Task} type and related utility functions, for stack-safe asynchronous programming with the ability of exception handling and auto-closeable resource management. \lstinline{Task} is a type alias of delimited continuation whose answer type is composed of \lstinline{TailRec} and \lstinline{Throwable} in the approach described in Section~\ref{Composable delimited continuation}.

  According to the result of the benchmarks shown in Section~\ref{Benchmarks}, the computational performance of \lstinline{Task} in \textit{Dsl.scala} is comparable to state-of-the-art Scala asynchronous programming libraries when running in HotSpot Server VM, and it achieves significant higher performance than state-of-the-art libraries when running in GraalVM.
\end{description}

\section{Use cases}

We will some use cases of name-based CPS transformation and LDK or  in this section, to illustrate the simplicity of our approach, in comparison to previous solutions.

\subsection{Resolve the \lstinline{printf} problem, trivially}\label{resolve-printf-problem}

The type-safe \lstinline{printf} problem \cite{danvy1998functional} is often used to demonstrate the ability of modifying the answer type of a typed delimited continuation. The problem can be also resolved by \textit{Dsl.scala}'s CPS-transformation plug-ins as shown in Listing~\ref{printf}.

\begin{lstlisting}[caption={A solution of the type-safe \lstinline{printf} problem in \textit{Dsl.scala}},label={printf}]
object IntPlaceholder {
  @shift def unary_! : String = ???
  def cpsApply[Domain](f: String => Domain): Int => Domain = { i: Int =>
    f(i.toString)
  }
}

object StringPlaceholder {
  @shift def unary_! : String = ???
  def cpsApply[Domain](f: String => Domain): String => Domain = f
}

def f1 = "Hello World!"
def f2 = "Hello " + !StringPlaceholder + "!"
def f3 = "The value of " + !StringPlaceholder + " is " + !IntPlaceholder + "."

println(f1) // Output: Hello World!
println(f2("World")) // Output: Hello World!
println(f3("x")(3)) // Output: The value of x is 3.
\end{lstlisting}

This solution works because our plug-ins performs CPS-transformation for \lstinline{f1}, \lstinline{f2} and \lstinline{f3}, as shown in Listing~\ref{transformed-printf}.

\begin{lstlisting}[caption={The translated source code of \lstinline{Dsl.scala}-base solution of \lstinline{printf} problem},label={transformed-printf}]
// The type of f1 is inferred as `String`
def f1 = "Hello World!"

// The type of f2 is inferred as `String => String`
def f2 = StringPlaceholder.cpsApply { tmp =>
  "Hello " + tmp + "!"
}

// The type of f3 is inferred as `String => Int => String`
def f3 = StringPlaceholder.cpsApply { tmp0 =>
  IntPlaceholder.cpsApply { tmp1 =>
    "The value of " + tmp0 + " is " + tmp1 + "."
  }
}
\end{lstlisting}

Our solution is conciser than the solution with Scala Continuations, because:
\begin{enumerate*}
  \item No explicit \lstinline{reset} is required, as reset is automatically added by the \lstinline{ResetEverywhere} plug-in.
  \item No explicit \lstinline{@cps} type annotation is required, since the \lstinline{BangNotation} plug-in is name-based. The type of \lstinline{f1}, \lstinline{f2} and \lstinline{f3} can be inferred automatically, according to Scala's type inference algorithm for closures.
\end{enumerate*}

\subsection{The underscore trick}\label{The underscore trick}

As described in Section~\ref{Implementation}, our compiler plug-ins automatically perform \lstinline{reset} control operation for every function. However, a complex continuation is usually executed across multiple functions, which requires an approach to prevent the automatically performed \lstinline{reset} control operation.

We will propose two approaches to resolve the problem. The first solution is called ``underscore trick'', which will be discussed in this section. Another solution is automatically derived \lstinline{Return} LDK, which will be described in Section~\ref{Composable delimited continuation}.

For example, in addition to \lstinline{yield}, Python generators also allow the \lstinline{return} and \lstinline{yield from} keywords. A generator that contains both \lstinline{yield} and \lstinline{return} keywords can be invoked by \lstinline{yield from} in another generator. The elements \lstinline{yield}ed in the former generator will be added into the latter generator, and the return value of the former generator can be used in the latter generator, too. An example of \lstinline{return} and \lstinline{yield from} is shown in Listing~\ref{returnable_generator}.

\begin{lstlisting}[language=Python,style=Python3,caption={Use \lstinline{yield from} and \lstinline{return} in Python generators},label={returnable_generator}]

def returnable_generator() -> Generator[str, None, int]:
  yield 'inside returnable_generator'
  return 1

def generator_test() -> Iterator[str]:
  yield 'before returnable_generator'
  v = yield from returnable_generator()
  yield 'after returnable_generator'
  yield f'the return value of returnable_generator is {v}'

# Output:
#   before returnable_generator
#   inside returnable_generator
#   after returnable_generator
#   the return value of returnable_generator is 1
print(*generator_test(), sep='\n')
\end{lstlisting}

Unlike generators introduced in Section~\ref{Implementing LDKs as ordinary delimited continuations}, \lstinline{returnable_generator} has the additional ability of returning values, thus its return type becomes to \lstinline{Generator[str, None, int]}, where \lstinline{str} is the iterator element type and \lstinline{int} is the type to return \footnote{Note that the declared return type and the type to return are different in Python generators. In other words, the \lstinline{return} keyword in Python ``lifts'' the plain value to a \lstinline{Generator}.}.

When porting \lstinline{return} and \lstinline{yield from} to Scala, the return type should indicate both the element type and the type to return, thus \lstinline{Stream} is not applicable for return type any more. We can instead use the return type \lstinline{Continuation[Stream[String], Int]}, as shown in Listing~\ref{returnableGenerator}. It accepts a callback function \lstinline{k}, which can handle the \lstinline{Int} value being returned and resume the rest program in \lstinline{generatorTest}.

\begin{lstlisting}[caption={Returning an additional value in LDK-based generators},label={returnableGenerator}]
def returnableGenerator(): Continuation[Stream[String], Int] = { k =>
  !Yield("inside returnableGenerator")
  k(1)
}

def generatorTest(): Stream[String] = {
  !Yield("before returnableGenerator")
  val v = !Shift(returnableGenerator())
  !Yield("after returnableGenerator")
  !Yield(s"the return value of returnableGenerator is $v")
  Stream.empty
}

generatorTest.foreach(println)
\end{lstlisting}

As we had renamed \lstinline{apply} to \lstinline{cpsApply} in the CPS-transformation plug-in as described in Section~\ref{Implementation},  an additional \lstinline{Shift} LDK is required in \lstinline{generatorTest} to perform the continuation\footnote{There is an implicit conversion from \lstinline{Continuation} to \lstinline{Shift} LDK in \textit{Dsl.scala}, thus the explicit \lstinline{Shift()} call can be omitted. We keep the explicit instantiation of \lstinline{Shift} in this section for clarity.}. It can be considered as the LDK-based replacement of Python's \lstinline{yield from} keyword, which is defined as Listing~\ref{Shift}.

\begin{lstlisting}[caption={The definition of \lstinline{Shift} LDK},label={Shift}]
case class Shift[Domain, Value](continuation: Continuation[Domain, Value]) extends Keyword[Shift[Domain, Value], Value]
\end{lstlisting}

As described in Section~\ref{Adaptive library-defined keywords}, we had split the LDK declaration (i.e. a subtype of \lstinline{Keyword}) from its implementation (i.e. a \lstinline{Dsl} type class instance), a \lstinline{Dsl} type class instance of \lstinline{Dsl[Shift[Stream[String], Int], Stream[String], Int]} is required to perform \lstinline{!Shift} in the domain of \lstinline{Stream[String]}. The implementation should forward \lstinline{cpsApply} call to the underlying \lstinline{continuation} of the \lstinline{Shift} LDK, as shown in Listing~\ref{shiftDsl}.

\begin{lstlisting}[caption={The \lstinline{Dsl} instance of \lstinline{Shift} LDK, to forward \lstinline{cpsApply} to underlying \lstinline{continuation}},label={shiftDsl}]
implicit def shiftDsl[Domain, Value] =
  new Dsl[Shift[Domain, Value], Domain, Value] {
    def cpsApply(keyword: Shift[Domain, Value], handler: Value => Domain) =
      keyword.continuation(handler)
  }
\end{lstlisting}

The \lstinline{Shift} LDK can be considered as a simple wrapper of \lstinline{Continuation} that forward \lstinline{cpsApply} calls to the underlying \lstinline{continuation}.

Unlike Java or C++, a Scala code block can have its value $r$, which is the last statement in the block. A closure like $\{ k \Rightarrow p; k(r) \}$ can be rewritten as $\{ k \Rightarrow k \{ p; r \} \}$, and finally simplified as $\_ \{ p; r \}$ with the help of Scala's placeholder syntax. As a result, the \lstinline{returnableGenerator} function in Listing~\ref{returnableGenerator} can be simplified as Listing~\ref{returnableGenerator-underscore}.

\begin{lstlisting}[caption={Returning an additional value in LDK-based generators, written in the underscore trick},label={returnableGenerator-underscore}]
def returnableGenerator(): Continuation[Stream[String], Int] = _ {
  !Yield("inside returnableGenerator")
  1
}
\end{lstlisting}

Semantically, the automatically performed \lstinline{reset} control operator is prevented by appending a single underscore character in front of the method body. We call this usage of the underscore character the ``underscore trick''.

\subsection{\lstinline{Dsl} Derivation}\label{Composable delimited continuation}

Another solution to allow continuations to cross multiple functions is \lstinline{Dsl} Derivation.

In Section~\ref{Adaptive library-defined keywords}, we have present how to create an LDK for different domains, interpreted by different implementations of \lstinline{Dsl} type class instances. In this section, we will discuss derived \lstinline{Dsl} type class instances for an LDK, available in derived domains.

A derived domain means a domain whose type signature contains another domain, and a derived \lstinline{Dsl} means a \lstinline{Dsl} whose implementation internally invokes another \lstinline{Dsl}. For example, the domain \lstinline{Continuation[Stream[String], Int]}, which we used in Section~\ref{The underscore trick}, can be considered as a derived domain of \lstinline{Stream[String]}. The derived \lstinline{Dsl} that will be introduced later should be able to ``lift'' the domain \lstinline{Stream[String]} to \lstinline{Continuation[Stream[String], Int]}, without manually creation of closures in the ``underscore trick''.

For example, the native keyword \lstinline{return} in Python can early return a function, as shown in Listing~\ref{early_generator}.

\begin{lstlisting}[language=Python,style=Python3,caption={Use \lstinline{yield from} and \lstinline{return} in Python generators},label={early_generator}]
def early_generator(early_return: bool) -> Generator[str, None, int]:
  yield 'inside early_generator'
  if early_return:
    yield 'early return'
    return 1
  yield 'normal return'
  return 0

def early_generator_test() -> Iterator[str]:
  yield 'before early_generator'
  v = yield from early_generator(True)
  yield 'after early_generator'
  yield f'the return value of early_generator is {v}'

# Output:
#   before early_generator
#   inside early_generator
#   early return
#   after early_generator
#   the return value of early_generator is 1
print(*early_generator_test(), sep='\n')
\end{lstlisting}

Since the ability of early return is impossible to be implemented in the ``underscore trick'', we defined a new \lstinline{Return} LDK to port Python \lstinline{return} to Scala, as shown in Listing~\ref{Return} and Listing~\ref{earlyGenerator}. Note that native Scala keyword \lstinline{return} is not applicable here, because it lacks the ability of ``lifting'' values like Python's \lstinline{return} does in \lstinline{early_generator}.

\begin{lstlisting}[caption={The definition of \lstinline{Return} LDK},label={Return}]
case class Return[A](returnValue: A) extends Keyword[Return[A], Nothing]
\end{lstlisting}

\begin{lstlisting}[caption={Use \lstinline{Shift} and \lstinline{Return} in LDK-based generators},label={earlyGenerator}]
def earlyGenerator(earlyReturn: Boolean): Continuation[Stream[String], Int] = {
  !Yield("inside earlyGenerator")
  if (earlyReturn) {
    !Yield("early return")
    !Return(1)
  }
  !Yield("normal return")
  !Return(0)
}

def earlyGeneratorTest(): Stream[String] = {
  !Yield("before earlyGenerator")
  val v = !Shift(earlyGenerator(true))
  !Yield("after earlyGenerator")
  !Yield(s"the return value of earlyGenerator is $v")
  Stream.empty
}

earlyGeneratorTest.foreach(println)
\end{lstlisting}

Since we don't manually creating the closure of the \lstinline{Continuation}, the return type of \lstinline{earlyGenerator} becomes \lstinline{Continuation[Stream[String], Int]}, which requires some \lstinline{Dsl} instances that we have not defined. We list the type class instances required to compile Listing~\ref{earlyGenerator} below:

\begin{enumerate}
  \item \lstinline{Dsl[Yield[String], Stream[String], Unit]} \\ (required by \lstinline{!Yield} in \lstinline{earlyGeneratorTest})
  \label{DslYield}

  \item \lstinline{Dsl[Shift[Stream[String], Int], Stream[String], Int]} \\ (required by \lstinline{!Shift} in \lstinline{earlyGeneratorTest})
  \label{DslShift}
  
  \item \lstinline{Dsl[Yield[String], Continuation[Stream[String], Int], Unit]} \\ (required by \lstinline{!Yield} in \lstinline{earlyGenerator})
  \label{DslYieldContinuation}
  
  \item \lstinline{Dsl[Return[Int], Continuation[Stream[String], Int], Nothing]} \\ (required by \lstinline{!Return} in \lstinline{earlyGenerator})
  \label{DslReturn}
\end{enumerate}

As discussed in Section~\ref{The underscore trick}, \lstinline{Dsl} instance \ref{DslYield} and \ref{DslShift} can be resolved by \lstinline{yieldDsl} and \lstinline{shiftDsl}, respectively.

\lstinline{Dsl} instance \ref{DslYieldContinuation} and \lstinline{Dsl} instance \ref{DslReturn} are new instances, which can be derived from original \lstinline{Dsl}s.

\lstinline{Dsl} instance \ref{DslYieldContinuation} should allow registering a callback \lstinline{handler} and then return a new continuation, whose return type is \lstinline{Stream[String]}. Thus, the \lstinline{Yield[String]} keyword can be performed inside the newly created continuation, by the existing \lstinline{Dsl} instance \lstinline{yieldDsl[String, String]}. The extracted value \lstinline{v} and final handler \lstinline{k} is then passed to \lstinline{handler} to continue the execution of rest program, as shown in Listing~\ref{yieldContinuationDsl}.

\begin{lstlisting}[caption={The derived \lstinline{Dsl} instance for \lstinline{Yield} LDK, which can be used in a \lstinline{Continuation}},label={yieldContinuationDsl}]
implicit def yieldContinuationDsl = {
  new Dsl[Yield[String], Continuation[Stream[String], Int], Unit] {
    def cpsApply(keyword: Yield[String], handler: Unit => Continuation[Stream[String], Int]): Continuation[Stream[String], Int] = { k =>
      val v = !keyword
      handler(v)(k)
    }
  }
}
\end{lstlisting}

As described in Section~\ref{Implementation}, \lstinline{!keyword} will be desugared to \lstinline[mathescape=true]|keyword.cpsApply { v => $\hdots$ }|, which is equivalent to \lstinline[mathescape=true]|yieldDsl[String, String].cpsApply(keyword, { v => $\hdots$ })| after inlining \lstinline{Keyword.cpsApply}. Therefore, \lstinline{yieldContinuationDsl} can be considered as a derived \lstinline{Dsl} instance of implicitly resolved \lstinline{yieldDsl}.

The implementation of \lstinline{yieldContinuationDsl} can be generalized to any other LDKs, because \lstinline{yieldContinuationDsl} does not touch any internal state of \lstinline{Yield} except passing \lstinline{Yield} to \lstinline{yieldDsl}. Any instance of \lstinline{Dsl[Keyword, Continuation[LeftDomain, RightDomain], Value]} can be derived from \lstinline{Dsl[Keyword, LeftDomain, Value]} as shown in Listing~\ref{derivedContinuationDsl}.

\begin{lstlisting}[caption={The generic derived \lstinline{Dsl} instance for any LDK, which can be used in a \lstinline{Continuation}},label={derivedContinuationDsl}]
implicit def derivedContinuationDsl[Keyword, LeftDomain, RightDomain, Value](
  implicit restDsl: Dsl[Keyword, LeftDomain, Value]
) = {
  new Dsl[Keyword, Continuation[LeftDomain, RightDomain], Value] {
    def cpsApply(keyword: Keyword, handler: Value => Continuation[LeftDomain, RightDomain]): Continuation[LeftDomain, RightDomain] = { k =>
      restDsl.cpsApply(keyword, { v =>
        handler(v)(k)
      })
    }
  }
}
\end{lstlisting}

Now the required \lstinline{Dsl} instance \ref{DslYieldContinuation} can be resolved from either \lstinline{yieldContinuationDsl}, or, more generically, \lstinline{derivedContinuationDsl(yieldDsl)}.


Similarly, since a \lstinline{!Return} LDK immediately returns from the current function, the implementation of \lstinline{Dsl} instance for \lstinline{!Return} should skip the rest part of the function, which is captured as a callback function passed to \lstinline{cpsApply}, as shown in Listing~\ref{returnDsl}. Then, the \lstinline{Dsl} instance \ref{DslReturn} can be resolved as \lstinline{derivedContinuationDsl(returnDsl)}.

\begin{lstlisting}[caption={The \lstinline{Dsl} instance of \lstinline{Return} LDK, to skip the registered callback function},label={returnDsl}]
implicit def returnDsl[A] =
  new Dsl[Return[A], A, Nothing] {
    def cpsApply(keyword: Return[A], handler: Nothing => A) =
      keyword.returnValue
  }
\end{lstlisting}

\lstinline{Dsl} derivation enables heterogeneous LDKs in one function, whose return type is composed from the required domain of those LDKs. We will present another example of creating extensible effects with the help of \lstinline{Dsl} derivation in Section~\ref{Multiple mutable states}.

\subsection{Mutable states}

Purely functional programming languages usually do not support first-class mutable variables. In those languages, mutable states can be implemented in state monads. In this section, we will present an alternative approach based on LDK to simulate mutable variable in a pure language \footnote{Scala is an impure language, but we don't use Scala's native \lstinline{var} or other impure features when simulating mutable states, therefore, our approach can be ported to Haskell or other pure languages as described in Section~\ref{Haskell implementation}.}. Unlike state monads, our LDK-based approach is more straightforward, and supports multiple mutable states without manually lifting.

\subsubsection{Single mutable state}\label{Single mutable state}

We use unary function as the domain of mutable state. The parameter of the unary function can be read from \lstinline{Get} LDK, and changed by \lstinline{Put} LDK, which are defined in Listing~\ref{Get} and Listing~\ref{Put}, respectively.

\begin{lstlisting}[caption={The definition of \lstinline{Get} LDK},label={Get}]
case class Get[S]() extends Keyword[Get[S], S]
\end{lstlisting}

\begin{lstlisting}[caption={The definition of \lstinline{Put} LDK},label={Put}]
case class Put[S](value: S) extends Keyword[Put[S], Unit]
\end{lstlisting}

Listing~\ref{upperCasedLastCharacter} is an example that creates a unary function that accepts a string parameter and returns the upper-cased last character of the parameter. The initial value is read from \lstinline{Get} LDK, then it is changed to upper-case by \lstinline{Put} LDK. At last, another \lstinline{Get} LDK is performed to read again  the changed value, and the last character is returned.

\begin{lstlisting}[caption={Using \lstinline{Get} and \lstinline{Put} in a unary function},label={upperCasedLastCharacter}]
def upperCasedLastCharacter: String => Char = {
  val initialValue = !Get[String]()
  !Put(initialValue.toUpperCase)

  val upperCased = !Get[String]()
  Function.const(upperCased.last)
}

// Output: O
println(upperCasedLastCharacter("foo"))
\end{lstlisting}

The \lstinline{Dsl} instances for \lstinline{Get} and \lstinline{Put} used in \lstinline{upperCasedLastCharacter} are shown in Listing~\ref{getDsl} and Listing~\ref{putDsl}. The \lstinline{Dsl} instance for \lstinline{Get} LDK passes the \lstinline{currentValue} to the \lstinline{handler} of current LDK, and then continues the enclosing unary function; the \lstinline{Dsl} instance for \lstinline{Put} LDK ignores \lstinline{previousValue} and continues the enclosing unary function with the new \lstinline{value} in \lstinline{Put}.

\begin{lstlisting}[caption={The \lstinline{Dsl} instance for \lstinline{Get} LDK},label={getDsl}]

implicit def getDsl[S0, S <: S0, A] =
  new Dsl[Get[S0], S => A, S0] {
    def cpsApply(keyword: Get[S0], handler: S0 => S => A): S => A = { currentValue =>
      handler(currentValue)(currentValue)
    }
  }
\end{lstlisting}

\begin{lstlisting}[caption={The \lstinline{Dsl} instance for \lstinline{Put} LDK},label={putDsl}]
implicit def putDsl[S0, S >: S0, A] =
  new Dsl[Put[S0], S => A, Unit] {
    def cpsApply(keyword: Put[S0], handler: Unit => S => A): S => A = { previousValue =>
      handler(())(keyword.value)
    }
  }
\end{lstlisting}

Traditionally, the data type of state monad is an opaque type alias of \lstinline{S => (S, A)}, which is more complicated than our domain type \lstinline{S => A}, indicating state monads are potentially less efficient than LDK-based implementation. We will discuss the reason why monad-based DSL are more complicated and less efficient than LDK-based DSL in Section~\ref{Monads}.

\subsubsection{Multiple mutable states}\label{Multiple mutable states}

\lstinline{Get} and \lstinline{Put} LDKs can be performed on multiple mutable states as well. The domain types are curried functions in those use cases.

In Listing~\ref{formatter}, we present an example to create a \lstinline{formatter} that performs \lstinline{Put} on a \lstinline{Vector[Any]} to store parts of the string content. At last, a \lstinline{Return} LDK is performed at last to concatenate those parts. The \lstinline{formatter} internally performs different types of \lstinline{Get} LDK to retrieve different parameters.

\begin{lstlisting}[caption={Using \lstinline{Get} and \lstinline{Put} in a curried function},label={formatter}]
def formatter: Double => Int => Vector[Any] => String = {
  !Put(!Get[Vector[Any]] :+ "x=")
  !Put(!Get[Vector[Any]] :+ !Get[Double])
  !Put(!Get[Vector[Any]] :+ ",y=")
  !Put(!Get[Vector[Any]] :+ !Get[Int])

  !Return((!Get[Vector[Any]]).mkString)
}

// Output: x=0.5,y=42
println(formatter(0.5)(42)(Vector.empty))
\end{lstlisting}

Since we had introduced \lstinline{Dsl} instance for \lstinline{Get} and \lstinline{Put} LDKs in unary functions, now we only need a derived \lstinline{Dsl} instance to port these LDKs in curried functions, as shown in Listing~\ref{derivedFunction1Dsl}.

\begin{lstlisting}[caption={Derived \lstinline{Dsl} instance in a curried function},label={derivedFunction1Dsl}]
implicit def derivedFunction1Dsl[Keyword, State, Domain, Value](
  implicit restDsl: Dsl[Keyword, Domain, Value]
): Dsl[Keyword, State => Domain, Value] =
new Dsl[Keyword, State => Domain, Value] {
  def cpsApply(keyword: Keyword, handler: Value => State => Domain): State => Domain = { state: State =>
    restDsl.cpsApply(keyword, handler(_)(state))
  }
}
\end{lstlisting}

By combining \lstinline{getDsl} and \lstinline{derivedFunction1Dsl} together, the Scala compiler automatically searches matched type in the curried function when resolving the implicit \lstinline{Dsl} instance for a \lstinline{Get} LDK. For example, \lstinline{!Get[Vector[Any]]()} reads the third parameter of the \lstinline{formatter}. It will be translated to \lstinline[mathescape=true]|Get[Vector[Any]]().cpsApply { _ => $\hdots$ }|, where the \lstinline{cpsApply} call requires an instance of type \lstinline{Dsl[Get[Vector[Any]], Double => Int => Vector[Any] => String, Vector[Any]]}, which can resolved as \lstinline{derivedFunction1Dsl(derivedFunction1Dsl(getDsl))}. Similarly, the \lstinline{Dsl} instance for reading the first parameter and the second parameter can be resolved as \lstinline{getDsl} and \lstinline{derivedFunction1Dsl(getDsl)}, respectively.

Derived \lstinline{Dsl} instance for \lstinline{Put} and \lstinline{Return} can be resolved similarly. Since all the \lstinline{!Put} LDK in \lstinline{formatter} write the third parameter, their \lstinline{Dsl} instances can be resolved as \lstinline{derivedFunction1Dsl(derivedFunction1Dsl(putDsl))}.

Similarly, The \lstinline{Dsl} instance for \lstinline{!Return} can be resolved as \lstinline{derivedFunction1Dsl(derivedFunction1Dsl(derivedFunction1Dsl(returnDsl)))}.

Now we had demonstrated a simple and straightforward solution for the feature of multiple mutable states, with the help of nested \lstinline{Dsl} derivation. Alternate approaches of multiple mutable states will be discussed in Section~\ref{Monad transformers} and Section~\ref{Effect handlers}.


\subsection{Asynchronous programming}\label{Asynchronous programming}

With the help of \lstinline{Dsl} derivation, a complex DSL can be composed of simple features. For example, we provided a type alias \lstinline{Task} for asynchronous programming, as a higher performance replacement of \lstinline{scala.concurrent.Future}, as shown in Listing~\ref{Task}. A new infix type alias \lstinline{!!} is used instead of \lstinline{Continuation}, as a clearer notation for nested \lstinline{Continuation} types.
\begin{lstlisting}[caption={The definition of asynchronous \lstinline{Task}},label={Task}]
type !![Domain, Value] = Continuation[Domain, Value]
type Task[A] = TailRec[Unit] !! Throwable] !! A
\end{lstlisting}

\lstinline{Task} supports the features of tail call optimization and exception handling. Each feature corresponds to a part the type signature. \lstinline{scala.util.control.TailCalls.TailRec} is used for tail call optimization, and \lstinline{scala.Throwable} is used to represent the internal exceptional state.

We create some derived \lstinline{Dsl}s to handle exceptions, which support domains whose types match the pattern of \lstinline[mathescape=true]{($L_i$ !! $\hdots$ !! $L_0$ !! Throwable !! $R_0$ !! $\hdots$ !! $R_i$)}, and some derived \lstinline{Dsl}s to optimize tail calls as trampolines, which support domains whose types match the pattern of \lstinline[mathescape=true]{(TailRec[$\hdots$] !! $R_0$ !! $\hdots$ !! $R_i$)}, where $L_0 \hdots L_i$ and $R_0 \hdots R_i$ are arbitrary number of types\footnote{Those \lstinline{Dsl}s are implemented in the \lstinline{Dsl} derivation technique described in Section~\ref{Composable delimited continuation}. Unfortunately, they are too sophisticated to include in this paper. Check the artifact for the complete implementation}. Therefore, \lstinline{Dsl} instances for \lstinline{Task} are composed from these orthogonal features.

In Section~\ref{An asynchronous HTTP client}, we will present how to create an asynchronous HTTP client from \lstinline{Task}; in  Section~\ref{Parallel execution}, we will introduce the usage of \lstinline{Task[Seq[A]]}, which collects the results of multiple tasks into a \lstinline{Seq}, either executed in parallel or sequentially.

\subsubsection{An asynchronous HTTP client}\label{An asynchronous HTTP client}

Listing~\ref{httpClient} is an example of an HTTP client built from low-level Java NIO.2 asynchronous IO operations.

\begin{lstlisting}[caption={An asynchronous HTTP client},label={httpClient}]
def readAll(channel: AsynchronousByteChannel, destination: ByteBuffer): Task[Unit] = _ {
  if (destination.remaining > 0) {
    val numberOfBytesRead: Int = !Read(channel, destination)
    numberOfBytesRead match {
      case -1 =>
      case _  => !readAll(channel, destination)
    }
  } else {
    throw new IOException("The response is too big to read.")
  }
}

def writeAll[Domain](channel: AsynchronousByteChannel, destination: ByteBuffer): Task[Unit] = _ {
  while (destination.remaining > 0) {
    !Write(channel, destination)
  }
}

def asynchronousHttpClient(url: URL): Task[String] = _ {
  val socket = AsynchronousSocketChannel.open()
  try {
    val port = if (url.getPort == -1) 80 else url.getPort
    val address = new InetSocketAddress(url.getHost, port)
    !Connect(socket, address)
    val request = ByteBuffer.wrap(s"GET ${url.getPath} HTTP/1.1\r\nHost:${url.getHost}\r\nConnection:Close\r\n\r\n".getBytes)
    !writeAll(socket, request)
    val MaxBufferSize = 100000
    val response = ByteBuffer.allocate(MaxBufferSize)
    !readAll(socket, response)
    response.flip()
    io.Codec.UTF8.decoder.decode(response).toString
  } finally {
    socket.close()
  }
}
\end{lstlisting}

The ``underscore trick'' is used to allow \lstinline{Task} to be executed across functions.

We defined \lstinline{Connect}, \lstinline{Read} and \lstinline{Write} LDKs to register handlers to Java NIO.2 asynchronous IO operators. In addition to \lstinline{Task} domain, those LDKs also support any domains that match types of \lstinline[mathescape=true]{($\hdots$ !! Unit !! Throwable !! $\hdots$)} or \lstinline[mathescape=true]{($\hdots$ !! TailRec[Unit] !! Throwable !! $\hdots$)}\footnote{Check the artifact for complete implementation.}.

\lstinline[mathescape=true]{!readAll($\hdots$)} and \lstinline[mathescape=true]{!writeAll($\hdots$)} are equivalent to \lstinline[mathescape=true]{!Shift(readAll($\hdots$))} and \lstinline[mathescape=true]{!Shift(writeAll($\hdots$))}. The explicit \lstinline{Shift} calls are omitted because we provided an implicit conversion from any \lstinline{Continuation}s(including \lstinline{Task}s) to \lstinline{Shift} LDKs.

We also provided a \lstinline{blockingAwait} method in an implicit class, to blocking await the result of the asynchronous task, therefore, \lstinline{asynchronousHttpClient} can be used synchronously, as shown in Listing~\ref{usingAsynchonousHttpClient}.

\begin{lstlisting}[caption={Using the example HTTP client},label={usingAsynchonousHttpClient}]
val httpResponse = asynchronousHttpClient(new URL("http://example.com/")).blockingAwait
httpResponse should startWith("HTTP/1.1 200 OK")
\end{lstlisting}

\subsubsection{Parallel execution}\label{Parallel execution}

Another useful LDK for asynchronous programming is \lstinline{Fork}, which duplicate the current control flow, and the child control flow are executed in parallel, similar to the POSIX \lstinline{fork} system call, as shown in Listing~\ref{usingHttpClientInParallel}.

\begin{lstlisting}[caption={Using HTTP client in parallel},label={usingHttpClientInParallel}]
val Urls = Seq(
  new URL("http://example.com/"),
  new URL("http://example.org/")
)
def parallelTask: Task[Seq[String]] = {
  val url: URL = !Fork(Urls)
  val content: String = !httpClient(url)
  !Return(content)
}

val Seq(fileContent0, fileContent1) = parallelTask.blockingAwait
assert(fileContent0.startsWith("HTTP/1.1 200 OK"))
assert(fileContent1.startsWith("HTTP/1.1 200 OK"))
% \end{lstlisting}

Since the execution of \lstinline{parallelTask} is forked, the two URLs would be downloaded in parallel. The results are then collected into a \lstinline{Task} of \lstinline{Seq} at the \lstinline{!Return} LDK.

The \lstinline{Task} implemented in \textit{Dsl.scala} is light-weight and faster. See Section~\ref{Benchmarks} for the performance benchmark between \lstinline{dsl.task.Task}, \lstinline{scala.concurrent.Future}, \lstinline{scalaz.concurrent.Task} and \lstinline{monix.eval.Task}.

\subsection{Collection comprehensions}\label{Collection comprehensions}

List comprehension or array comprehension is a feature to create a collection based on some other collections, which has been implemented as first class feature in many programming languages including Scala. In this section, we will present the \lstinline{Each} LDK, which allows collection comprehensions for arbitrary collection types. Unlike other first class comprehension, our LDK-based collection comprehension collaborates with other LDKs, thus allowing creating complex code of effects or actions in collection comprehensions.

\subsubsection{Heterogeneous comprehensions}\label{Heterogeneous comprehensions}

Suppose we want to calculate all composite numbers below $n$, the program can be written in Scala's native \lstinline{for}-comprehension as shown in Listing~\ref{compositeNumbersBelow-for}.

\begin{lstlisting}[caption={Calculating all composite numbers below $n$ with \lstinline{for}-comprehension},label={compositeNumbersBelow-for}]
def compositeNumbersBelow(n: Int) = (for {
  i <- 2 until math.ceil(math.sqrt(n)).toInt
  j <- 2 * i until n by i
} yield j).to[Set]
\end{lstlisting}

The \lstinline{compositeNumbersBelow} can be ported to LDK-based collection comprehension with the following steps:

\begin{enumerate}
  \item Replacing the \lstinline{for} keyword and the trailing \lstinline[mathescape=true]{.to[$CollectionType$]} by the heading $CollectionType$.
  \item Replacing every \lstinline[mathescape=true]{$p$ <- $e$} by \lstinline[mathescape=true]{val $p$ = !Each($e$)}.
  \item Moving the value to \lstinline{yield} to the last expression position of the comprehension block.
\end{enumerate}

Therefore, Listing~\ref{compositeNumbersBelow-for} can be rewrite to Listing~\ref{compositeNumbersBelow} with the help of the \lstinline{Each} LDK, or Listing~\ref{compositeNumbersBelow-simplified} after removing the temporary variable \lstinline{j}.

\begin{lstlisting}[caption={Calculating all composite numbers below $n$ with \lstinline{Each} LDK},label={compositeNumbersBelow}]
def compositeNumbersBelow(n: Int): Set[Int] = Set {
  val i = !Each(2 until math.ceil(math.sqrt(n)).toInt)
  val j = !Each(2 * i until n by i)
  j
}
\end{lstlisting}


\begin{lstlisting}[caption={Calculating all composite numbers below $n$ with \lstinline{Each} LDK, the simplicied version},label={compositeNumbersBelow-simplified}]
def compositeNumbersBelow(n: Int): Set[Int] = Set {
  val i = !Each(2 until math.ceil(math.sqrt(n)).toInt)
  !Each(2 * i until n by i)
}

// Output: Set(10, 14, 6, 9, 12, 8, 4)
println(compositeNumbersBelow(15))
\end{lstlisting}

Note that \lstinline{compositeNumbersBelow} creates a \lstinline{Set}, which is different from the type of source collection. Our LDK-base collection comprehension allows heterogeneous source collection types. Even other collection-like types, including \lstinline{Array} and \lstinline{String}, are supported, as shown in Listing~\ref{heterogeneous}.

\begin{lstlisting}[caption={LDK-based heterogeneous collection comprehension based on \lstinline{Array} and \lstinline{String}},label={heterogeneous}]
def heterogeneous = List { !Each(Array("foo", "bar", "baz")) + !Each("LDK") }

// Output: List(fooL, fooD, fooK, barL, barD, barK, bazL, bazD, bazK)
println(heterogeneous)
\end{lstlisting}
\subsubsection{Filters}

We also provides the \lstinline{Continue} LDK to skip an element from the source collections. It provides the similar feature to the \lstinline{if} clause in Scala's native \lstinline{for}-comprehension. An example of using \lstinline{Continue} LDK to calculate prime numbers is shown in Listing~\ref{primeNumbersBelow}.

\begin{lstlisting}[caption={Calculating all prime numbers below $n$ with \lstinline{Each} and \lstinline{Continue} LDK},label={primeNumbersBelow}]
def primeNumbersBelow(maxNumber: Int) = List {
  val compositeNumbers = compositeNumbersBelow(maxNumber)
  val i = !Each(2 until maxNumber)
  if (compositeNumbers(i)) !Continue
  i
}

// Output: List(2, 3, 5, 7, 11, 13)
println(primeNumbersBelow(15))
\end{lstlisting}

\subsubsection{Asynchronous comprehensions}\label{Asynchronous comprehensions}

The \lstinline{Each} LDK can be used in \lstinline{Task} of collections as well, with the help of \lstinline{Dsl} derivation. The usage of \lstinline{Each} is very similar to the \lstinline{Fork} keyword. The only difference is that \lstinline{Each} sequentially executes tasks while \lstinline{Fork} executes tasks in parallel. For example, if we replace the \lstinline{Fork} LDK in Listing~\ref{usingHttpClientInParallel} by \lstinline{Each}, those URLs will be fetched sequentially, as shown in Listing~\ref{usingHttpClientSequentially}.

\begin{lstlisting}[caption={Using HTTP client in parallel},label={usingHttpClientSequentially}]
def sequentialTask: Task[Seq[String]] = {
  val url: URL = !Each(Urls)
  val content: String = !httpClient(url)
  !Return(content)
}
\end{lstlisting}

\subsubsection{Generator comprehensions}\label{Generator comprehensions}

Since an \lstinline{Each} LDK works in any function that returns a collection, it can be also used in a \lstinline{Stream} function, which support the \lstinline{Yield} LDK as well. As a result, generator and collection comprehension can be used together.

Suppose we are creating a function to prepare flags for invoking the \texttt{gcc} command line tool. Given a source file and a list of include paths, it should return a \lstinline{Stream} of the command line.
It can be implemented from the \lstinline{Yield}, \lstinline{Each} and \lstinline{Continue} as shown in Listing~\ref{gccFlagBuilder}.

\begin{lstlisting}[caption={Build a command-line by using generator and collection comprehension together},label={gccFlagBuilder}]
def gccFlagBuilder(sourceFile: String, includes: String*): Stream[String] = {
  !Yield("gcc")
  !Yield("-c")
  !Yield(sourceFile)
  val include = !Each(includes)
  !Yield("-I")
  !Yield(include)
  !Continue
}

// Output: List(gcc, -c, main.c, -I, lib1/include, -I, lib2/include)
println(gccFlagBuilder("main.c", "lib1/include", "lib2/include").toList)
\end{lstlisting}

\section{Benchmarks}\label{Benchmarks}

We created some benchmarks to evaluate the computational performance of code generated by our compiler plug-in for LDKs, especially, we are interesting how our name-based CPS transformation and other direct style DSL affect the performance in an effect system that support both asynchronous and synchronous effects.

Our benchmarks measured the performance of LDKs in the \lstinline{Task} domain mentioned in Section~\ref{Asynchronous programming}, along with other combination of effect system with direct style DSL, listed in Table \ref{combination}:

\begin{table}[htbp]
  \begin{tabular}{l|l}
    Effect System & direct style DSL \\
    \hline
    The \texttt{Task} LDK & name-based CPS transformation provided by \textit{Dsl.scala} \\
    Scala Future \cite{haller2012sip} & Scala Async \cite{haller2013sip} \\
    Scala Continuation library \cite{rompf2009implementing} & Scala Continuation compiler plug-in \\
    Monix tasks \cite{nedelcu2017monix} & \texttt{for} comprehension \\
    Cats effects \cite{typelevel2017cats} & \texttt{for} comprehension \\
    Scalaz Concurrent \cite{kenji2017scalaz} & \texttt{for} comprehension \\
  \end{tabular}
  \caption{The combination of effect system and direct style DSL being benchmarked}
  \label{combination}
\end{table}

\subsection{The performance of recursive functions in effect systems}

The purpose of the first benchmark is to determine the performance of recursive functions in various effect system, especially when a direct style DSL is used.

\subsubsection{The performance baseline}

In order to measure the performance impact due to direct style DSLs, we have to measure the performance baseline of different effect systems at first. We created some benchmarks for the most efficient implementation of a sum function in each effect system. These benchmarks perform the following computation:

\begin{itemize}
  \item Creating a \lstinline{List[X[Int]]} of 1000 tasks, where \lstinline{X} is the data type of task in the effect system.
  \item Performing recursive right-associated ``binds'' on each element to add the \lstinline{Int} to an accumulator, and finally produce a \lstinline{X[Int]} as a task of the sum result.
  \item Running the task and blocking awaiting the result.
\end{itemize}

Note that the tasks in the list is executed in the current thread or in a thread pool. We keep each task returning a simple pure value, because we want to measure the overhead of effect systems, not the task itself.

The ``bind'' operation means the primitive operation of each effect system. For Monix tasks, Cats effects, Scalaz Concurrent and Scala Continuations library, the ``bind'' operation is \lstinline{flatMap}; for \textit{Dsl.scala}, the ``bind'' operation is \lstinline{apply}, which may or may not be equivalent to \lstinline{flatMap} according to the type of the current domain.

We use the !-notation to perform the \lstinline{apply} in \textit{Dsl.scala}. The !-notation results the exact same Java bytecode to manually passing a callback function to \lstinline{apply} (Listing \ref{RawSum.dsl}).

\begin{lstlisting}[float=htbp,caption={The most efficient implementation of sum based on ordinary CPS function},label={RawSum.dsl}]
def loop(tasks: List[Task[Int]], accumulator: Int = 0)(callback: Int => TaskDomain): TaskDomain = {
  tasks match {
    case head :: tail =>
      // Expand to: Shift(head).apply(i => loop(tail, i + accumulator)(callback))
      loop(tail, !head + accumulator)(callback)
    case Nil =>
      callback(accumulator)
  }
}
\end{lstlisting}

However, direct style DSLs for other effect systems are not used in favor of raw \lstinline{flatMap} calls, in case of decay of the performance. Listing \ref{RawSum.future} shows the benchmark code for Scala Futures. The code for all the other effect systems are similar to it.

\begin{lstlisting}[float=htbp,caption={The most efficient implementation of sum based on Scala Futures},label={RawSum.future}]
def loop(tasks: List[Future[Int]], accumulator: Int = 0): Future[Int] = {
  tasks match {
    case head :: tail =>
      head.flatMap { i =>
        loop(tail, i + accumulator)
      }
    case Nil =>
      Future.successful(accumulator)
  }
}
\end{lstlisting}

The benchmark result is shown in Table \ref{RawSum} (larger score is better):

\begin{table}[htbp]
  \begin{tabular}{l|l|l|rl}
   \multicolumn{1}{c|}{\texttt{Benchmark}} & \texttt{executedIn} & \texttt{size} & \multicolumn{2}{c}{\texttt{Score, ops/s}} \\
  \hline
  \texttt{RawSum.cats} & \texttt{thread-pool} & \texttt{1000} & \texttt{799.072} & \scriptsize $\pm$ \texttt{3.094}  \\
  \texttt{RawSum.cats} & \texttt{current-thread} & \texttt{1000} & \texttt{26932.907} & \scriptsize $\pm$ \texttt{845.715}  \\
  \texttt{RawSum.dsl} & \texttt{thread-pool} & \texttt{1000} & \texttt{729.947} & \scriptsize $\pm$ \texttt{4.359}  \\
  \texttt{RawSum.dsl} & \texttt{current-thread} & \texttt{1000} & \texttt{31161.171} & \scriptsize $\pm$ \texttt{589.935}  \\
  \texttt{RawSum.future} & \texttt{thread-pool} & \texttt{1000} & \texttt{575.403} & \scriptsize $\pm$ \texttt{3.567}  \\
  \texttt{RawSum.future} & \texttt{current-thread} & \texttt{1000} & \texttt{876.377} & \scriptsize $\pm$ \texttt{8.525}  \\
  \texttt{RawSum.monix} & \texttt{thread-pool} & \texttt{1000} & \texttt{743.340} & \scriptsize $\pm$ \texttt{11.314}  \\
  \texttt{RawSum.monix} & \texttt{current-thread} & \texttt{1000} & \texttt{55421.452} & \scriptsize $\pm$ \texttt{251.530}  \\
  \texttt{RawSum.scalaContinuation} & \texttt{thread-pool} & \texttt{1000} & \texttt{808.671} & \scriptsize $\pm$ \texttt{3.917}  \\
  \texttt{RawSum.scalaContinuation} & \texttt{current-thread} & \texttt{1000} & \texttt{17391.684} & \scriptsize $\pm$ \texttt{385.138}  \\
  \texttt{RawSum.scalaz} & \texttt{thread-pool} & \texttt{1000} & \texttt{722.743} & \scriptsize $\pm$ \texttt{11.234}  \\
  \texttt{RawSum.scalaz} & \texttt{current-thread} & \texttt{1000} & \texttt{15895.606} & \scriptsize $\pm$ \texttt{235.992}  \\
  \end{tabular}
  \caption{The benchmark result of sum for performance baseline}
  \label{RawSum}
\end{table}

The \lstinline{Task} alias of continuation-passing style function used with \textit{Dsl.scala} is quite fast. \textit{Dsl.scala}, Monix and Cats Effects score on top 3 positions for either tasks running in the current thread or in a thread pool.

\subsubsection{The performance impact of direct style DSLs}

In this section, we will present the performance impact when different syntax notations are introduced. For ordinary CPS functions, we added one more !-notation to avoid manually passing the \lstinline{callback} in the previous benchmark (Listing \ref{LeftAssociatedSum.dsl}, \ref{RightAssociatedSum.dsl}). For other effect systems, we refactored the previous sum benchmarks to use Scala Async, Scala Continuation's \lstinline{@cps} annotations, and \lstinline{for} comprehension, respectively (Listing \ref{LeftAssociatedSum.future}, \ref{RightAssociatedSum.future}, \ref{LeftAssociatedSum.scalaContinuation}, \ref{RightAssociatedSum.scalaContinuation}, \ref{LeftAssociatedSum.scalaz}, \ref{RightAssociatedSum.scalaz}).

\begin{lstlisting}[float=htbp,caption={Left-associated sum based on LDKs of \textit{Dsl.scala}},label={LeftAssociatedSum.dsl}]
def loop(tasks: List[Task[Int]]): Task[Int] = _ {
  tasks match {
    case head :: tail =>
      !head + !loop(tail)
    case Nil =>
      0
  }
}
\end{lstlisting}

\begin{lstlisting}[float=htbp,caption={Right-associated sum based on LDKs of \textit{Dsl.scala}},label={RightAssociatedSum.dsl}]
def loop(tasks: List[Task[Int]], accumulator: Int = 0): Task[Int] = _ {
  tasks match {
    case head :: tail =>
      !loop(tail, !head + accumulator)
    case Nil =>
      accumulator
  }
}
\end{lstlisting}

\begin{lstlisting}[float=htbp,caption={Left-associated sum based on Scala Async},label={LeftAssociatedSum.future}]
def loop(tasks: List[Future[Int]]): Future[Int] = async {
  tasks match {
    case head :: tail =>
      await(head) + await(loop(tail))
    case Nil =>
      0
  }
}
\end{lstlisting}

\begin{lstlisting}[float=htbp,caption={Right-associated sum based on Scala Async},label={RightAssociatedSum.future}]
def loop(tasks: List[Future[Int]], accumulator: Int = 0): Future[Int] = async {
  tasks match {
    case head :: tail =>
      await(loop(tail, await(head) + accumulator))
    case Nil =>
      accumulator
  }
}
\end{lstlisting}

\begin{lstlisting}[float=htbp,caption={Left-associated sum based on Scala Continuation plug-in},label={LeftAssociatedSum.scalaContinuation}]
def loop(tasks: List[() => Int @suspendable]): Int @suspendable = {
  tasks match {
    case head :: tail =>
      head() + loop(tail)
    case Nil =>
      0
  }
}
\end{lstlisting}

\begin{lstlisting}[float=htbp,caption={Right-associated sum based on Scala Continuation plug-in},label={RightAssociatedSum.scalaContinuation}]
def loop(tasks: List[() => Int @suspendable], accumulator: Int = 0): Int @suspendable = {
  tasks match {
    case head :: tail =>
      loop(tail, head() + accumulator)
    case Nil =>
      accumulator
  }
}
\end{lstlisting}

\begin{lstlisting}[float=htbp,caption={Left-associated sum based on \lstinline{for} comprehension},label={LeftAssociatedSum.scalaz}]
def loop(tasks: List[Task[Int]]): Task[Int] = {
  tasks match {
    case head :: tail =>
      for {
        i <- head
        accumulator <- loop(tail)
      } yield i + accumulator
    case Nil =>
      Task(0)
  }
}
\end{lstlisting}

\begin{lstlisting}[float=htbp,caption={Right-associated sum based on \lstinline{for} comprehension},label={RightAssociatedSum.scalaz}]
def loop(tasks: List[Task[Int]], accumulator: Int = 0): Task[Int] = {
  tasks match {
    case head :: tail =>
      for {
        i <- head
        r <- loop(tail, i + accumulator)
      } yield r
    case Nil =>
      Task.now(accumulator)
  }
}
\end{lstlisting}

Note that reduced sum can be implemented in either left-associated recursion or right-associated recursion. The above code contains benchmark for both cases. The benchmark result is shown in Table \ref{LeftAssociatedSum}, \ref{RightAssociatedSum}:

\begin{table}[htbp]
  \begin{tabular}{l|l|l|rl}
   \multicolumn{1}{c|}{\texttt{Benchmark}} & \texttt{executedIn} & \texttt{size} & \multicolumn{2}{c}{\texttt{Score, ops/s}} \\
  \hline
  \texttt{LeftAssociatedSum.cats} & \texttt{thread-pool} & \texttt{1000} & \texttt{707.940} & \scriptsize $\pm$ \texttt{10.497}  \\
  \texttt{LeftAssociatedSum.cats} & \texttt{current-thread} & \texttt{1000} & \texttt{16165.442} & \scriptsize $\pm$ \texttt{298.072}  \\
  \texttt{LeftAssociatedSum.dsl} & \texttt{thread-pool} & \texttt{1000} & \texttt{729.122} & \scriptsize $\pm$ \texttt{7.492}  \\
  \texttt{LeftAssociatedSum.dsl} & \texttt{current-thread} & \texttt{1000} & \texttt{19856.493} & \scriptsize $\pm$ \texttt{386.225}  \\
  \texttt{LeftAssociatedSum.future} & \texttt{thread-pool} & \texttt{1000} & \texttt{339.415} & \scriptsize $\pm$ \texttt{1.486}  \\
  \texttt{LeftAssociatedSum.future} & \texttt{current-thread} & \texttt{1000} & \texttt{410.785} & \scriptsize $\pm$ \texttt{1.535}  \\
  \texttt{LeftAssociatedSum.monix} & \texttt{thread-pool} & \texttt{1000} & \texttt{742.836} & \scriptsize $\pm$ \texttt{9.904}  \\
  \texttt{LeftAssociatedSum.monix} & \texttt{current-thread} & \texttt{1000} & \texttt{19976.847} & \scriptsize $\pm$ \texttt{84.222}  \\
  \texttt{LeftAssociatedSum.scalaContinuation} & \texttt{thread-pool} & \texttt{1000} & \texttt{657.721} & \scriptsize $\pm$ \texttt{9.453}  \\
  \texttt{LeftAssociatedSum.scalaContinuation} & \texttt{current-thread} & \texttt{1000} & \texttt{15103.883} & \scriptsize $\pm$ \texttt{255.780}  \\
  \texttt{LeftAssociatedSum.scalaz} & \texttt{thread-pool} & \texttt{1000} & \texttt{670.725} & \scriptsize $\pm$ \texttt{8.957}  \\
  \texttt{LeftAssociatedSum.scalaz} & \texttt{current-thread} & \texttt{1000} & \texttt{5113.980} & \scriptsize $\pm$ \texttt{110.272}  \\
  \end{tabular}
  \caption{The benchmark result of left-associated sum in direct style DSLs}
  \label{LeftAssociatedSum}
\end{table}

\begin{table}[htbp]
  \begin{tabular}{l|l|l|rl}
   \multicolumn{1}{c|}{\texttt{Benchmark}} & \texttt{executedIn} & \texttt{size} & \multicolumn{2}{c}{\texttt{Score, ops/s}} \\
  \hline
    \texttt{RightAssociatedSum.cats} & \texttt{thread-pool} & \texttt{1000} & \texttt{708.441} & \scriptsize $\pm$ \texttt{9.201}  \\
    \texttt{RightAssociatedSum.cats} & \texttt{current-thread} & \texttt{1000} & \texttt{15971.331} & \scriptsize $\pm$ \texttt{315.063}  \\
    \texttt{RightAssociatedSum.dsl} & \texttt{thread-pool} & \texttt{1000} & \texttt{758.152} & \scriptsize $\pm$ \texttt{4.600}  \\
    \texttt{RightAssociatedSum.dsl} & \texttt{current-thread} & \texttt{1000} & \texttt{22393.280} & \scriptsize $\pm$ \texttt{677.752}  \\
    \texttt{RightAssociatedSum.future} & \texttt{thread-pool} & \texttt{1000} & \texttt{338.471} & \scriptsize $\pm$ \texttt{2.188}  \\
    \texttt{RightAssociatedSum.future} & \texttt{current-thread} & \texttt{1000} & \texttt{405.866} & \scriptsize $\pm$ \texttt{2.843}  \\
    \texttt{RightAssociatedSum.monix} & \texttt{thread-pool} & \texttt{1000} & \texttt{736.533} & \scriptsize $\pm$ \texttt{10.856}  \\
    \texttt{RightAssociatedSum.monix} & \texttt{current-thread} & \texttt{1000} & \texttt{21687.351} & \scriptsize $\pm$ \texttt{107.249}  \\
    \texttt{RightAssociatedSum.scalaContinuation} & \texttt{thread-pool} & \texttt{1000} & \texttt{654.749} & \scriptsize $\pm$ \texttt{7.983}  \\
    \texttt{RightAssociatedSum.scalaContinuation} & \texttt{current-thread} & \texttt{1000} & \texttt{12080.619} & \scriptsize $\pm$ \texttt{274.878}  \\
    \texttt{RightAssociatedSum.scalaz} & \texttt{thread-pool} & \texttt{1000} & \texttt{676.180} & \scriptsize $\pm$ \texttt{7.705}  \\
    \texttt{RightAssociatedSum.scalaz} & \texttt{current-thread} & \texttt{1000} & \texttt{7911.779} & \scriptsize $\pm$ \texttt{79.296}  \\
  \end{tabular}
  \caption{The benchmark result of right-associated sum in direct style DSLs}
  \label{RightAssociatedSum}
\end{table}

The result demonstrates that the name-based CPS transformation provided by \textit{Dsl.scala} is faster than all other direct style DSLs in the right-associated sum benchmark. The \textit{Dsl.scala} version sum consumes a constant number of memory during the loop, because we implemented a tail-call detection in our CPS-transform compiler plug-in, and the \lstinline{Dsl} interpreter for \lstinline{Task} use a trampoline technique \cite{tarditi1992no}. On the other hand, the benchmark result of Monix Tasks, Cats Effects and Scalaz Concurrent posed a significant performance decay, because they costs O(n) memory due to the \lstinline{map} call generated by \lstinline{for} comprehension, although those effect systems also built in trampolines. In general, the performance of recursive monadic binds in a \lstinline{for} comprehension is always underoptimized due to the inefficient \lstinline{map}.

\subsection{The performance of collection manipulation in effect systems}

The previous sum benchmarks measured the performance of manually written loops, but usually we may want to use higher-ordered functions to manipulate collections. We want to know how those higher-ordered functions can be expressed in direct style DSLs, and how would the performance be affected by direct style DSLs.

In this section, we will present the benchmark result for computing the Cartesian product of lists.

\subsubsection{The performance baseline}

As we did in sum benchmarks, we created some benchmarks to maximize the performance for Cartesian product. Our benchmarks create the Cartesian product from \lstinline{traverseM} for Scala Future, Cats Effect, Scalaz Concurrent and Monix Tasks. Listing \ref{RawCartesianPruduct.future} shows the benchmark code for Scala Future.

\begin{lstlisting}[float=htbp,caption={Cartesian product for Scala Future, based on Scalaz's \lstinline{traverseM}},label={RawCartesianPruduct.future}]
def cellTask(taskX: Future[Int], taskY: Future[Int]): Future[List[Int]] = async {
  List(await(taskX), await(taskY))
}

def listTask(rows: List[Future[Int]], columns: List[Future[Int]]): Future[List[Int]] = {
  rows.traverseM { taskX =>
    columns.traverseM { taskY =>
      cellTask(taskX, taskY)
    }
  }
}
\end{lstlisting}

Scala Async or \lstinline{for} comprehension is used in element-wise task \lstinline{cellTask}, but the collection manipulation \lstinline{listTask} is kept as manually written higher order function calls, because neither Scala Async nor \lstinline{for} comprehension supports \lstinline{traverseM}.

The benchmark for \textit{Dsl.scala} is entirely written in LDKs (Listing \ref{RawCartesianPruduct.dsl}):

\begin{lstlisting}[float=htbp,caption={Cartesian product for ordinary CPS functions, based on \textit{Dsl.scala}},label={RawCartesianPruduct.dsl}]
def cellTask(taskX: Task[Int], taskY: Task[Int]): Task[List[Int]] = _ {
  List(!taskX, !taskY)
}

def listTask(rows: List[Task[Int]], columns: List[Task[Int]]): Task[List[Int]] = {
  cellTask(!Each(rows), !Each(columns))
}
\end{lstlisting}

The \lstinline{Each} LDK is available here because it is adaptive. \lstinline{Each} LDK can be used in not only \lstinline{List[_]} domain, but also \lstinline{(_ !! Coll[_])} domain as long as \lstinline{Coll} is a Scala collection type that supports \lstinline{CanBuildFrom} type class.

We didn't benchmark Scala Continuation here because all higher ordered functions for \lstinline{List} do not work with Scala Continuation.

The benchmark result is shown in Table \ref{RawCartesianProduct}.

\begin{table}[htbp]
  \begin{tabular}{l|l|l|rl}
   \multicolumn{1}{c|}{\texttt{Benchmark}} & \texttt{executedIn} & \texttt{size} & \multicolumn{2}{c}{\texttt{Score, ops/s}} \\
  \hline
  \texttt{RawCartesianProduct.cats} & \texttt{thread-pool} & \texttt{50} & \texttt{136.415} & \scriptsize $\pm$ \texttt{1.939}  \\
  \texttt{RawCartesianProduct.cats} & \texttt{current-thread} & \texttt{50} & \texttt{1346.874} & \scriptsize $\pm$ \texttt{7.475}  \\
  \texttt{RawCartesianProduct.dsl} & \texttt{thread-pool} & \texttt{50} & \texttt{140.098} & \scriptsize $\pm$ \texttt{2.062}  \\
  \texttt{RawCartesianProduct.dsl} & \texttt{current-thread} & \texttt{50} & \texttt{1580.876} & \scriptsize $\pm$ \texttt{27.513}  \\
  \texttt{RawCartesianProduct.future} & \texttt{thread-pool} & \texttt{50} & \texttt{100.340} & \scriptsize $\pm$ \texttt{1.894}  \\
  \texttt{RawCartesianProduct.future} & \texttt{current-thread} & \texttt{50} & \texttt{93.678} & \scriptsize $\pm$ \texttt{1.829}  \\
  \texttt{RawCartesianProduct.monix} & \texttt{thread-pool} & \texttt{50} & \texttt{142.071} & \scriptsize $\pm$ \texttt{1.299}  \\
  \texttt{RawCartesianProduct.monix} & \texttt{current-thread} & \texttt{50} & \texttt{1750.869} & \scriptsize $\pm$ \texttt{18.365}  \\
  \texttt{RawCartesianProduct.scalaz} & \texttt{thread-pool} & \texttt{50} & \texttt{78.588} & \scriptsize $\pm$ \texttt{0.623}  \\
  \texttt{RawCartesianProduct.scalaz} & \texttt{current-thread} & \texttt{50} & \texttt{357.357} & \scriptsize $\pm$ \texttt{2.102}  \\
  \end{tabular}
  \caption{The benchmark result of Cartesian product for performance baseline}
  \label{RawCartesianProduct}
\end{table}

Monix tasks, Cats Effects and ordinary CPS functions created from \textit{Dsl.scala} are still the top 3 scored effect systems.

\subsubsection{The performance of collection manipulation in direct style DSLs}\label{The performance of collection manipulation in direct style DSLs}

We then refactored the benchmarks to direct style DSLs. Listing \ref{CartesianProduct.future} is the code for Scala Future, written in \lstinline{ListT} monad transformer provided by Scalaz. The benchmarks for Monix tasks, Scalaz Concurrent are also rewritten in the similar style.

\begin{lstlisting}[float=htbp,caption={Cartesian product for Scala Future, based on \lstinline{ListT} transformer},label={CartesianProduct.future}]
def listTask(rows: List[Future[Int]], columns: List[Future[Int]]): Future[List[Int]] = {
  for {
    taskX <- ListT(Future.successful(rows))
    taskY <- ListT(Future.successful(columns))
    x <- taskX.liftM[ListT]
    y <- taskY.liftM[ListT]
    r <- ListT(Future.successful(List(x, y)))
  } yield r
}.run
\end{lstlisting}

With the help of \lstinline{ListT} monad transformer, we are able to merge \lstinline{cellTask} and \lstinline{listTask} into one function in a direct style \lstinline{for} comprehension, avoiding any manual written callback functions.

We also merged \lstinline{cellTask} and \lstinline{listTask} in the \textit{Dsl.scala} version of benchmark (Listing \ref{CartesianProduct.dsl}).

\begin{lstlisting}[float=htbp,caption={Cartesian product for ordinary CPS functions, in one function},label={CartesianProduct.dsl}]
def listTask: Task[List[Int]] = reset {
  List(!(!Each(inputDslTasks)), !(!Each(inputDslTasks)))
}
\end{lstlisting}

This time, Cats Effects are not benchmarked due to lack of \lstinline{ListT} in Cats. The benchmark result are shown in Table \ref{CartesianProduct}.

\begin{table}[htbp]
  \begin{tabular}{l|l|l|rl}
   \multicolumn{1}{c|}{\texttt{Benchmark}} & \texttt{executedIn} & \texttt{size} & \multicolumn{2}{c}{\texttt{Score, ops/s}} \\
  \hline
  \texttt{CartesianProduct.dsl} & \texttt{thread-pool} & \texttt{50} & \texttt{283.450} & \scriptsize $\pm$ \texttt{3.042}  \\
  \texttt{CartesianProduct.dsl} & \texttt{current-thread} & \texttt{50} & \texttt{1884.514} & \scriptsize $\pm$ \texttt{47.792}  \\
  \texttt{CartesianProduct.future} & \texttt{thread-pool} & \texttt{50} & \texttt{91.233} & \scriptsize $\pm$ \texttt{1.333}  \\
  \texttt{CartesianProduct.future} & \texttt{current-thread} & \texttt{50} & \texttt{150.234} & \scriptsize $\pm$ \texttt{20.396}  \\
  \texttt{CartesianProduct.monix} & \texttt{thread-pool} & \texttt{50} & \texttt{28.597} & \scriptsize $\pm$ \texttt{0.265}  \\
  \texttt{CartesianProduct.monix} & \texttt{current-thread} & \texttt{50} & \texttt{120.068} & \scriptsize $\pm$ \texttt{17.676}  \\
  \texttt{CartesianProduct.scalaz} & \texttt{thread-pool} & \texttt{50} & \texttt{31.110} & \scriptsize $\pm$ \texttt{0.662}  \\
  \texttt{CartesianProduct.scalaz} & \texttt{current-thread} & \texttt{50} & \texttt{87.404} & \scriptsize $\pm$ \texttt{1.734}  \\
  \end{tabular}
  \caption{The benchmark result of Cartesian product in direct style DSLs}
  \label{CartesianProduct}
\end{table}

Despite the trivial manual lift calls in \lstinline{for} comprehension, the monad transformer approach causes terrible computational performance in comparison to manually called \lstinline{traverseM}. In contrast, the performance of \textit{Dsl.scala} even got improved when \lstinline{cellTask} is inlined into \lstinline{listTask}.


\section{Related works}

Previous works related to \textit{Dsl.scala} can be divided into two categories:% \textit{direct style syntax} and \textit{generic protocol of control flow operators}.

\begin{description}
  \item[Generic protocols of control flow operators] are motivated the goal similar to our \lstinline{Dsl} type class. Operators of specific purposes can be implemented in a same protocol, therefore, users of those operators can use a common interface for different domains. Monads and delimited continuations are notable examples of such protocols.
  \item[Direct style notations] are similar syntaxes to our name-based CPS transformation. Those notations allow users to write sequential imperative style code that will be translated to CPS or monadic style that consist of nested closures. \lstinline{yield}, \lstinline{async} / \lstinline{await}, \lstinline{reset} / \lstinline{shift}, \lstinline{for}-comprehension, \lstinline{do}-notation and !-notation are notable examples of such notations.
\end{description}

\subsection{Generators}

A generator is a special procedure to lazily produce values, which can be consumed as an iterator. Early implementation of generators are shipped in Alphard \cite{shaw1977abstraction} and CLU \cite{liskov1977abstraction}, and the feature is now available in  Python, ECMAScript, C\#, and many other programming languages.

The execution of the generator will be paused at the \lstinline{yield} statement, and can be resumed when the consumer side of the generator asks for the next value. The \lstinline{yield} statement can be considered as a direct style notation for producer / consumer pattern.

Generators can be used for creating embedded DSLs:

\begin{itemize}
  \item The producer side \lstinline{yield}s command objects of the DSL.
  \item The consumer side interprets these produced command objects to actually perform operations.
\end{itemize}

However, the type of the command object is a protocol between the consumer and the producer, and must be determined in advance, therefore, the number of available commands in a generator is fixed. A generator DSL is not composable with other generator DSLs. In addition, generators are traditionally implemented as a first class feature by the compiler, thus they do not collaborate with other direct style notation unless modifying the compiler.

Unlike these first class generators, our LDK-based generators can be used along with other LDKs, including but not limited to \lstinline{Shift} (Section~\ref{The underscore trick}), \lstinline{Return} (Section~\ref{Composable delimited continuation}), \lstinline{Await} (Section~\ref{Collaborative library-defined keywords}), \lstinline{Each} (Section~\ref{Generator comprehensions}), without modifying the compiler.

\subsection{\lstinline{async}/\lstinline{await}}

\subsection{Delimited continuations}
% \lstinline{reset}/\lstinline{shift}

\subsection{\lstinline{for}-comprehension}\label{for-comprehension}

\subsection{\lstinline{do}-notation}\label{do-notation}


\subsection{!-notation}

\subsection{Monads}\label{Monads}

A monad is a generic protocol of control flow operators used in Haskell and many other functional programming languages. A monad defines two primary operators for creating monadic expressions of a certain type.
\begin{enumerate*}
  \item The \lstinline[language=Haskell,deletekeywords={return}]{return} operator \footnote{Also called \lstinline{point} or \lstinline{pure}.} lifts a plain value to a monadic value.
  \item The \lstinline{bind} operator \footnote{Also called \lstinline{flatMap} or \lstinline{>>=}.} composes two steps monadic expressions into one monadic value, where the second step is a handler to map the value of the first step into a new monadic value.
\end{enumerate*}

Since a monad is specified to a certain monadic data type, the capacity of a monadic data type is predetermined, unless introducing an additional abstract layer of interpreters. For example, the \lstinline{List} monad in Haskell \footnote{A Haskell \lstinline{List} is lazy by default, equivalent to a Scala \lstinline{Stream}.} can be used to create a \lstinline{List} based on \lstinline{List}s, but it cannot create a \lstinline{List} based on other collection types, nor creating a \lstinline{List} from a generator.

In our LDK approach, we remove the limitation of monads by separating the concept of monadic value into two distinguishing concepts: domain and library-defined keyword (LDK). A domain is the return type of its enclosing function, and an LDK is an operation on the domain. Therefore, a collection can be created from other collections or generators with different LDKs as discussed in Section~\ref{Heterogeneous comprehensions} and Section~\ref{Generator comprehensions}. 

In addition, separating domains and LDKs can lead simpler implementation. Our \lstinline{Get} and \lstinline{Put} can be used in the domain of ordinary unary functions, while the monadic data type for a state monad is more complicated, as discussed in Section~\ref{Single mutable state}. Also, the implementation of \lstinline{Cont} monad is more complicated, as it creates one more additional closure for each \lstinline{bind} operator, while the \lstinline{Shift} LDK for delimited continuation runs as a simple forwarder, which creates no more closure, as discussed in Section~\ref{The underscore trick}.

In fact, the \lstinline{bind} operator of a monad is equivalent to a special case of \lstinline{Dsl} when the domain type and the LDK type are the same, and the \lstinline[language=Haskell,deletekeywords={return}]{return} operator of a monad can be considered another special case of \lstinline{Dsl} when the LDK is a \lstinline{Return}, which holds a plain value of the domain type.

There are other workarounds to overcome the limitation of monads, which will be discussed in Section~\ref{Monad transformers}, Section~\ref{Free and Freer monads} and Section~\ref{Effect handlers}.

\subsubsection{Monad transformers}\label{Monad transformers}

Monad transformers are monads derived from other monads. ``Monad transformer'' is to ``monad'' as ``\lstinline{Dsl} derivation'' is to ``\lstinline{Dsl}''. The monadic data type can be composed at type level as a chain of monad transformers, so that various operations can be lifted to the same nested transformed monadic data type, which can be then used in a single monadic code block. The process to perform an operation in a monad transformer is shown in Figure~\ref{monad-transformer-lift}.

\begin{figure}[h t b p]
  \begin{dot2tex}[dot]
  digraph {
    rankdir=TB
    node [ shape=rect ]

    M [ texlbl="An operation" ];
    T1 [ texlbl="Lifted monadic value of the operation" ];
    T2 [ texlbl="The output monadic value" ];
    M -> T1 [ label="derived lift", texlbl="derived \texttt{lift}" ];
    T1 -> T2 [ label="derived bind", texlbl="derived \lstinline{bind}" ];
  }
  \end{dot2tex}
  \caption{What's happened when executing an operation in a monad transformer block}
  \label{monad-transformer-lift}
\end{figure}

However, as \cite{kiselyov2013extensible} pointed out, lifting a atomic type to a deeply nested transformed monadic data type is inefficient. The overhead of lifting a single operation increases as long as the number of nested monad transformers increases.

The inefficient lifting can be avoided in our \lstinline{Dsl} derivation approach, since an LDK already represents an operation for any compatible domains. Only the \lstinline{cpsApply} method in the \lstinline{Dsl} type class is derived, as shown in Figure~\ref{dsl-operation}. The performance improvement is also observed in the benchmark at Section~\ref{The performance of collection manipulation in direct style DSLs}.

\begin{figure}[h t b p]
  \begin{dot2tex}[dot]
  digraph {
    rankdir=TB
    node [ shape=rect ]

    M [ texlbl="An operation as a LDK" ];
    T [ texlbl="The output domain value" ];
    M -> T [ label="derived cpsApply", texlbl="derived \texttt{cpsApply}" ];
  }
  \end{dot2tex}
  \caption{What's happened when executing an operation in a \lstinline{Dsl} block}
  \label{dsl-operation}
\end{figure}


\subsubsection{Free and Freer monads}\label{Free and Freer monads}

\subsubsection{Effect handlers}\label{Effect handlers}

\section{Future work}

\subsection{Haskell implementation}\label{Haskell implementation}

\section{Discussion and Conclusion}

% In Section~\ref{Basic concepts}, we have demonstrated \lstinline{Dsl} type class can be considered as both superset of monads and delimited continuations. The additional ability of allowing

% % Straightforwardness, Extensibility and 
% In this section, we will present the ho

% address the straightforwardness, extensibility and performance problem when handle effects with monads, 

% However, monads are not extensible, 

% Since monads are often used to handle effects, in this section, we will present how to handle effects in \lstinline{Dsl.scala}.






% % , with some minor differences.

% % \begin{enumerate}
  
% %   \item Compiler-time instruction \lstinline{reset} is not necessary in our implementation, as the boundary of a delimited continuation is by default the enclosing function. Instead, \lstinline{reset} can be implemented as an ordinary Scala function shown in Listing \ref{bobLoggingParserReset}.
  
% %   \item All return types are kept as is in our implementation, instead of hijacking on the \lstinline{@cps} type.
% %   \label{as-is}

% %   \item Our implementation only performs CPS-transform explicitly on the !-notation, instead of implicit conversion between \lstinline{@cps} type and ordinary type.

% % \end{enumerate}

% % Because of (\ref{as-is}), CPS-translated function produced by our compiler plug-in always has the same answer type as the return type, which is called the ``domain'' of a DSL. Even then, our approach still allows explicit answer type by using the underscore trick shown in Listing \ref{bobLoggingParserUnderscore}.














% \section{Using library-defined keywords}\label{Using library-defined keywords}

% In this section, we will show some use cases from the perspective of the user of LDKs.


% \subsection{Creating generators}\label{Creating generators}

% % Suppose Alice is creating an Xorshift pseudo-random number generator \cite{marsaglia2003xorshift}, and she wants to store the generated numbers in a lazily evaluated infinite stream. 

% % The usage of Alice's pseudo-random number generator is shown as below:

% % \begin{lstlisting}[caption={Using Alice's pseudo-random number generator},label={generatedNumbers}]
% % val generatedNumbers = aliceRandomGenerator(seed = 2463534242)
% % println(generatedNumbers(0))
% % println(generatedNumbers(1))
% % println(generatedNumbers(2))
% % \end{lstlisting}

% % Alice is a functional programming language developer. She wants to avoid mutable variables in the implementation. Unfortunately, a pseudo-random number generator usually has an internal state that are changed during generate new random number.

% % With the help of the built-in LDK \lstinline{Yield} from \textit{Dsl.scala}, Alice can implement the generator as a recursive function that produce the next random number in each iteration.

% % \begin{lstlisting}[caption={The implementation of Alice's pseudo-random number generator},label={aliceRandomGenerator}]
% % import dsl.keywords.Yield
% % def aliceRandomGenerator(seed: Int): Stream[Int] = {
% %   val tmp1 = seed ^ (seed << 13)
% %   val tmp2 = tmp1 ^ (tmp1 >>> 17)
% %   val tmp3 = tmp2 ^ (tmp2 << 5)
% %   !Yield(tmp3)
% %   aliceRandomGenerator(tmp3)
% % }
% % \end{lstlisting}

% % \lstinline{aliceRandomGenerator} does not throw a \lstinline{StackOverflowError}, because the execution of \lstinline{aliceRandomGenerator} will be paused at the LDK \lstinline{Yield}, and it will be resumed when the caller is looking for the next number.

% % \lstinline{Yield} is an LDK to produce a value for a lazily evaluated \lstinline{Stream}, similar to the \lstinline[language=Python,style=Python3]{yield} keyword in C\#, JavaScript or Python. B is to say, \lstinline{Stream} is the domain where the domain-specific LDK \lstinline{Yield} can be used. More generally, all LDKs are domain-specific, where the word ``domain'' stands for the return type of the enclosing function.

% \subsection{Creating generators with an additional return value}

% In this use case, we will demonstrate how to add logging to existing functions using the \lstinline{Yield} LDK.

% Suppose Bob has a function to parse JSON text. The parser is fault-tolerant, since it returns the \lstinline{defaultValue} for invalid input  (Listing \ref{bobParser}).

% \begin{lstlisting}[caption={The original implementation of Bob's parser},label={bobParser}]
% import scala.util.parsing.json._
% def bobParser(jsonContent: String, defaultValue: JSONType): JSONType = {
%   JSON.parseRaw(jsonContent) match {
%     case Some(json) =>
%       callback(json)
%     case None =>
%       callback(defaultValue)
%   }
% }
% \end{lstlisting}

% Then, Bob wants to add some logs to his existing parser. He learned from Alice's use case, and wonders if he can \lstinline{Yield} log messages to a \lstinline{Stream[String]} during parsing.

% However, unlike Alice's case, Bob's parser should return both the parsed JSON objects and the collected logs. It's impossible in C\#'s \lstinline[language=Python,style=Python3]{yield}, because \lstinline[language=Python,style=Python3]{yield} does not work in a method that returns a JSON object.

% Bob resolves the problem by creating a delimited continuation. The parsed JSON object is handled by a callback function instead of return value. Thus the return value is still a \lstinline{Stream}, allowing \lstinline{Yield}ing log messages (Listing \ref{bobLoggingParser}).

% \begin{lstlisting}[caption={The implementation of Bob's logging parser},label={bobLoggingParser}]
% import dsl.Dsl.!!
% def bobLoggingParser(jsonContent: String, defaultValue: JSONType): Stream[String] !! JSONType = { (callback: JSONType => Stream[String]) =>
%   !Yield(s"I am going to parse the JSON text $jsonContent...")
%   JSON.parseRaw(jsonContent) match {
%     case Some(json) =>
%       !Yield(s"Succeeded to parse $jsonContent")
%       callback(json)
%     case None =>
%       !Yield(s"Failed to parse $jsonContent")
%       callback(defaultValue)
%   }
% }
% \end{lstlisting}

% The return type of Bob's new parser is \lstinline{(Stream[String] !! JSONType)}, which is an alias to the delimited continuation \lstinline{((JSONType => Stream[String]) => Stream[String])}, indicating it produces both a \lstinline{scala.util.parsing.json.JSONType} and a \lstinline{Stream} of logs.

% After Bob created the first version of delimited continuation, he then found that the closure can be simplified with the help of Scala's placeholder syntax (Listing \ref{bobLoggingParserUnderscore}).

% \begin{lstlisting}[caption={The implementation of Bob's logging parser, the underscore placeholder version},label={bobLoggingParserUnderscore}]
% def bobLoggingParserUnderscore(jsonContent: String, defaultValue: JSONType): Stream[String] !! JSONType = _ {
%   !Yield(s"I am going to parse the JSON text $jsonContent...")
%   JSON.parseRaw(jsonContent) match {
%     case Some(json) =>
%       !Yield(s"Succeeded to parse $jsonContent")
%       json
%     case None =>
%       !Yield(s"Failed to parse $jsonContent")
%       defaultValue
%   }
% }
% \end{lstlisting}

% Alternately, Bob can use the pre-defined function \lstinline{reset} instead of the underscore placeholder (Listing \ref{bobLoggingParserReset}).

% \begin{lstlisting}[caption={The implementation of Bob's logging parser, the reset version},label={bobLoggingParserReset}]
% def reset[R, A](a: => A): R !! A = _(a)

% def bobLoggingParserReset(jsonContent: String, defaultValue: JSONType): Stream[String] !! JSONType = reset {
%   !Yield(s"I am going to parse the JSON text $jsonContent...")
%   JSON.parseRaw(jsonContent) match {
%     case Some(json) =>
%       !Yield(s"Succeeded to parse $jsonContent")
%       json
%     case None =>
%       !Yield(s"Failed to parse $jsonContent")
%       defaultValue
%   }
% }
% \end{lstlisting}

% Then, the user of Bob's parser calls \lstinline{bobLoggingParserReset} to handle both results (Listing \ref{usingBobLoggingParserDelay}):

% \begin{enumerate}
%   \item The JSON result in a callback function.
%   \item The logs from return value.
% \end{enumerate}

% \begin{lstlisting}[caption={Using Bob's parser},label={usingBobLoggingParserDelay}]
% val logs = bobLoggingParserReset("""{"key":"value"}""", JSONArray(Nil)) { json =>
%   json should be(JSONObject(Map("key" -> "value")))
%   Stream("done")
% }
% logs should be(
%   Stream(
%     "I am going to parse the JSON text {\"key\":\"value\"}...",
%     "Succeeded to parse {\"key\":\"value\"}",
%     "done"
%   )
% )
% \end{lstlisting}

% The use case of Bob's parser demonstrates how to enable additional LDKs into existing ordinary functions. Generally, an LDK user can introduce a new domain that supports more LDKs to an existing method with the two changes:

% \begin{enumerate}
%   \item Inserting a \lstinline{NewDomain!!} prefix to the return type (\lstinline{Stream[String]!!} in Bob's case).
%   \item Inserting an underscore or a \lstinline{reset} before the method body.
% \end{enumerate}

% \subsection{Using multiple LDKs at once}\label{Using multiple LDKs at once}

% In this use case, we will demonstrate how to use multiple library-defined keywords in one function.

% Suppose Carol is creating a line splitter from a file. Carol wants to lazily read each line of a file to a \lstinline{Stream}, and automatically close the file handle after reading the last line, and finally return the total number of lines.

% Carol will use the \lstinline{Yield} LDK to append a line to the \lstinline{Stream}, and the \lstinline{AutoClose} LDK to manage the life-cycle of the file handle.

% \lstinline{Yield} LDK is only available in a function that returns \lstinline{Stream} or \lstinline{(Stream[_] !! _)} as we already knows. Similarly, the \lstinline{AutoClose} LDK is only available in a function that returns \lstinline{(_ !! Throwable !! _)}. So, Carol makes her line splitter return \lstinline{(Stream[String] !! Throwable !! Int)} to enable both LDKs (Listing \ref{carolLineSplitter}).

% \begin{lstlisting}[caption={Carol's line splitter},label={carolLineSplitter}]
% import dsl.Dsl.!!
% import dsl.keywords.AutoClose
% import dsl.keywords.Yield
% import dsl.keywords.Shift
% import java.nio.file._, Files._

% def carolLineSplitter(path: Path): Stream[String] !! Throwable !! Int = reset {
%   val reader = !AutoClose(newBufferedReader(path))

%   def loop(lineNumber: Int): Stream[String] !! Throwable !! Int = _ {
%     reader.readLine() match {
%       case null =>
%         lineNumber
%       case line =>
%         !Yield(line)
%         !Shift(loop(lineNumber + 1))
%     }
%   }

%   !loop(0)
% }
% \end{lstlisting}

% Note that the return type of \lstinline{loop}, \lstinline{(Stream[String] !! Throwable !! Int)}, is a delimited continuation, Carol needs \lstinline{Shift} LDK as the first-class delimited continuation operator\cite{danvy1990abstracting,asai2009typing} to invoke \lstinline{loop} recursively.

% The type \lstinline{(Stream[String] !! Throwable !! Int)} returned from \lstinline{carolLineSplitter} contains the following data:

% \begin{itemize}
%   \item A \lstinline{Stream} of each lines of the file, as the final return value.
%   \item An optional \lstinline{Throwable} of the exception thrown during reading the file, which can be handled by a callback function.
%   \item An \lstinline{Int} of the total number of lines in the file, which can be handled by another callback function.
% \end{itemize}

% The example code of using Carol's line splitter is shown in Listing \ref{usingCarolLineSplitter}.

% \begin{lstlisting}[caption={Using Carol's line splitter},label={usingCarolLineSplitter}]
% val allLines: Stream[String] = carolLineSplitter(Paths.get("multiline.txt")) { numberOfLines: Int =>
%   println(s"There are ${numberOfLines} lines in multiline.txt")
%   Function.const(Stream.empty)(_)
% } { e: Throwable =>
%   println("An error occurred during splitting multiline.txt")
% }
% \end{lstlisting}

% In this use case, Carol created a function from three library-defined keywords.

% \begin{enumerate}
%   \item \lstinline{AutoClose} for resource management, similar to C++'s RAII feature.
%   \item \lstinline{Yield} for lazily append values to a \lstinline{Stream}, similar to Python, C\# or ECMAScript's \lstinline[language=Python,style=Python3]{yield} keyword.
%   \item \lstinline{Shift} for awaiting a value from a task, similar to Python, C\# or ECMAScript's \lstinline[language=Python,style=Python3]{await} keyword.
% \end{enumerate}

% What is interesting is that our library-defined keywords are more like first-class features than compiler-defined keywords. Despite the fact that Python 3.5, C\# and ECMAScript do not support automatic resource management, they also do not support using both \lstinline[language=Python,style=Python3]{yield} and \lstinline[language=Python,style=Python3]{await} in one function, even when \lstinline[language=Python,style=Python3]{yield} and \lstinline[language=Python,style=Python3]{await} are supported respectively, and Python 3.6 needs a special implementation of Asynchronous Generators \cite{pep525} to use both \lstinline[language=Python,style=Python3]{yield} and \lstinline[language=Python,style=Python3]{await}, while our library-defined keywords can collaborate with arbitrary other LDKs by composing extra domains on the return type.


% \subsection{Monadic programming}\label{Monadic programming}

% Despite LDKs directly implemented in \textit{Dsl.scala}, we also provide some LDKs as adapters to monads and other type classes.

% The built-in \lstinline{Monadic} LDK can be used as an adapter to \lstinline{scalaz.Monad}, to create monadic code from imperative syntax, similar to the !-notation in Idris.

% For example, suppose Erin is creating a program that counts lines of code under a directory. She uses the \lstinline{Monadic} LDK store the result in a \lstinline{Stream} of line count of each file (Listing \ref{erinMonadicCounter}).

% \begin{lstlisting}[caption={Erin's line of code counter, the monadic version},label={erinMonadicCounter}]

% import java.io.File
% import dsl.keywords.Monadic
% import dsl.domains.scalaz._
% import scalaz.std.stream._
% def erinMonadicCounter(file: File): Stream[Int] = Stream {
%   if (file.isDirectory) {
%     file.listFiles() match {
%       case null =>
%         // Unable to open `file`
%         !Monadic(Stream.empty[Int])
%       case children =>
%         // Import this implicit conversion to omit the Monadic keyword
%         import dsl.keywords.Monadic.implicitMonadic
%         val child: File = !children.toStream
%         !erinMonadicCounter(child)
%     }
%   } else {
%     scala.io.Source.fromFile(file).getLines.size
%   }
% }
% \end{lstlisting}

% The previous code requires a \lstinline{toStream} conversion on \lstinline{children}, because \lstinline{children}'s type \lstinline{Array[File]} does not fit the \lstinline{F} type parameter in \lstinline{scalaz.Monad.bind} \cite{kenji2017scalaz}.

% There is a \lstinline{Each} LDK in \textit{Dsl.scala} to extract each element in a Scala collection, based on {CanBuildFrom} type class instead of monads. The \lstinline{Each} behavior is similar to \lstinline{Monadic}, except the collection type can vary.

% Thus, Erin can extract each element from an \lstinline{Array} with the help of \lstinline{Each} LDK in Listing \ref{erinMixedCounter},
% even when the enclosing domain is still a \lstinline{Stream}.

% \begin{lstlisting}[caption={Erin's line of code counter, mixed \lstinline{Monad}-based and \lstinline{CanBuildFrom}-based LDKs},label={erinMixedCounter}]

% import java.io.File
% import dsl.keywords.Monadic, Monadic.implicitMonadic
% import dsl.keywords.Each
% import dsl.domains.scalaz._
% import scalaz.std.stream._
% def erinMixedCounter(file: File): Stream[Int] = Stream {
%   if (file.isDirectory) {
%     file.listFiles() match {
%       case null =>
%         // Unable to open `file`
%         !Stream.empty[Int]
%       case children =>
%         val child: File = !Each(children)
%         !erinMixedCounter(child)
%     }
%   } else {
%     scala.io.Source.fromFile(file).getLines.size
%   }
% }
% \end{lstlisting}

% As shown the \lstinline{erinMixedCounter}, Dsl.scala allows \lstinline{Each} and other non-monadic LDKs to work along with monads, which is impossible in Haskell's do-notation or Idris's !-notation.

% However, Erin still wants to add one more feature to the LOC counter. Considering the line counter implemented in previous example may be failed for some files,
% due to permission issue or other IO problem,
% Erin wants to use an \lstinline{OptionT} monad transformer to mark those failed file as a \lstinline{None} (Listing \ref{erinTransformerCounter}).

% \begin{lstlisting}[caption={Erin's line of code counter, using an \lstinline{OptionT} monad transformer},label={erinTransformerCounter}]
% import scalaz._
% import java.io.File
% import dsl.keywords.Monadic, Monadic.implicitMonadic
% import dsl.domains.scalaz._
% import scalaz.std.stream._
% def erinTransformerCounter(file: File): OptionT[Stream, Int] = OptionT.some {
%   if (file.isDirectory) {
%     file.listFiles() match {
%       case null =>
%         // Unable to open `file`
%         !OptionT.none[Stream, Int]
%       case children =>
%         val child: File = !Stream(children: _*)
%         !erinTransformerCounter(child)
%     }
%   } else {
%     scala.io.Source.fromFile(file).getLines.size
%   }
% }
% \end{lstlisting}

% Note that our LDKs are adaptive to the domain it belongs to. Thus, instead of explicit lifting as \lstinline{!Monadic(OptionT.optionTMonadTrans.liftM(Stream(children: _*)))}, Erin can simply write \lstinline{!Stream(children: _*)}. This implicit lifting feature looks like Idris's effect monads \cite{brady2013programming}, though the mechanisms is different from \lstinline{implicit lift} in Idris.

% \section{Creating library-defined keywords}\label{Creating library-defined keywords}

% LDKs introduced in Section \ref{Using library-defined keywords} are optional libraries, activated by common compiler-time CPS-transform rules, which are implemented as a Scala compiler plug-in. In this section, we will present the implementation of some LDKs, and the compiler-time generated code for !-notations written by LDK users.

% \textit{Dsl.scala} ships with a compiler plug-in that supports both nonadaptive LDKs and adapters LDKs. A nonadaptive LDK must belongs to in an exact domain, while an adaptive LDK works in various types of domains.

% \subsection{Nonadaptive LDKs}

% A Nonadaptive LDK is simply a delimited continuation, along with a syntactic \lstinline{unary_!} method for !-notation. For example, the \lstinline{Yield} LDK described at Section \ref{Creating generators} can be implemented as shown in Listing \ref{NonadaptiveYield}.

% % \begin{lstlisting}[caption={The \lstinline{Yield} LDK, the nonadaptive version},label={NonadaptiveYield}]
% % import dsl.Dsl.shift
% % case class Yield[A](element: A) {

% %   @shift
% %   @compileTimeOnly("Calls to this method will be translated to apply calls by the compiler plug-in")
% %   def unary_! : Value = ???

% %   @inline
% %   def apply(handler: Unit => Stream[A]): Stream[A] = {
% %     new Stream.Cons(element, handler(()))
% %   }
% % }
% % \end{lstlisting}

% Calls to \lstinline{unary_!} method will be translated to \lstinline{apply} calls by our compiler plug-in. For example, \lstinline{aliceRandomGenerator} in Listing \ref{aliceRandomGenerator} will be translated to the code shown in Listing \ref{translatedAliceRandomGenerator} by our compiler plug-in:

% \begin{lstlisting}[caption={The translated code for Alice's pseudo-random number generator},label={translatedAliceRandomGenerator}]
% def aliceRandomGenerator(seed: Int): Stream[Int] = {
%   val tmp1 = seed ^ (seed << 13)
%   val tmp2 = tmp1 ^ (tmp1 >>> 17)
%   val tmp3 = tmp2 ^ (tmp2 << 5)
%   Yield(tmp3) { _: Unit =>
%     aliceRandomGenerator(tmp3)
%   }
% }
% \end{lstlisting}

% And Listing \ref{bobLoggingParser} or Listing \ref{bobLoggingParserUnderscore} will be translated to Listing \ref{translatedBobLoggingParser}:

% \begin{lstlisting}[caption={The translated code for Bob's parser},label={translatedBobLoggingParser}]
% import dsl.Dsl.!!
% def bobLoggingParser(jsonContent: String, defaultValue: JSONType): Stream[String] !! JSONType = { (callback: JSONType => Stream[String]) =>
%   Yield(s"I am going to parse the JSON text $jsonContent...") { _: Unit =>
%     JSON.parseRaw(jsonContent) match {
%       case Some(json) =>
%         Yield(s"Succeeded to parse $jsonContent") { _: Unit =>
%           callback(json)
%         }
%       case None =>
%         Yield(s"Failed to parse $jsonContent") { _: Unit =>
%           callback(defaultValue)
%         }
%     }
%   }
% }
% \end{lstlisting}

% Our compiler plug-in performs CPS-transform in a similar approach to Scala Continuations \cite{rompf2009implementing}, with some minor differences.

% \begin{enumerate}
  
%   \item Compiler-time instruction \lstinline{reset} is not necessary in our implementation, as the boundary of a delimited continuation is by default the enclosing function. Instead, \lstinline{reset} can be implemented as an ordinary Scala function shown in Listing \ref{bobLoggingParserReset}.
  
%   \item All return types are kept as is in our implementation, instead of hijacking on the \lstinline{@cps} type.
%   \label{as-is}

%   \item Our implementation only performs CPS-transform explicitly on the !-notation, instead of implicit conversion between \lstinline{@cps} type and ordinary type.

% \end{enumerate}

% Because of (\ref{as-is}), CPS-translated function produced by our compiler plug-in always has the same answer type as the return type, which is called the ``domain'' of a DSL. Even then, our approach still allows explicit answer type by using the underscore trick shown in Listing \ref{bobLoggingParserUnderscore}.

% \subsection{Adaptive LDKs}

% All \textit{Dsl.scala} built-in LDKs are adaptive, which can collaborate with other LDKs. For example, \lstinline{Yield} is adaptive, since it works not only in functions that return \lstinline{Stream[_]}, but also \lstinline{(Stream[_] !! _)}, \lstinline{(Stream[_] !! _ !! _)}, etc.

% Those LDKs are adaptive because they all extends the \lstinline{trait Keyword}, which has a ad-hoc polymorphic \lstinline{apply} method (Listing \ref{Keyword}).

% % \begin{lstlisting}[caption={The ad-hoc polymorphism in \lstinline{Keyword}},label={Keyword}]
% % trait Keyword[Self, Value] extends Any { this: Self =>

% %   @shift
% %   @compileTimeOnly("Calls to this method will be translated to apply calls by the compiler plug-in")
% %   def unary_! : Value = ???

% %   def apply[Domain](handler: Value => Domain)(implicit dsl: Dsl[Self, Domain, Value]): Domain = {
% %     dsl.apply(this, handler)
% %   }

% % }
% % \end{lstlisting}

% The functionality of \lstinline{apply} is implemented in type class instances of \lstinline{Dsl} (Listing \ref{Dsl}).

% The adaptive version of \lstinline{Yield} LDK ships with a type class instance of \lstinline{Dsl[Yield[A], Stream[A], Unit]}, allowing the \lstinline{!Yield} notation in functions that return \lstinline{Stream[A]}

% % \begin{lstlisting}[caption={The \lstinline{Yield} LDK, the adaptive version},label={Yield}]
% % case class Yield[A](element: A) extends Keyword[Yield[A], Unit]

% % object Yield {
% %   implicit def yieldDsl[A]: Dsl[Yield[A], Stream[A], Unit] =
% %     new Dsl[Yield[A], Stream[A], Unit] {
% %       def apply(keyword: Yield[A], mapper: Unit => Stream[A]): Stream[A] = {
% %         new Stream.Cons(keyword.element, mapper(()))
% %       }
% %     }
% % }
% % \end{lstlisting}

% To make \lstinline{Yield} LDK available for another domain, just provide a \lstinline{Dsl} type class instance for other types.

% Listing \ref{derivedContinuationDsl} shows a \lstinline{Dsl} that allows an LDK be available for \lstinline{Domain!!Value} as long as the LDK is available for \lstinline{Domain}.  \footnote{LDKs is also adaptive to domains other than continuations, such as a heterogeneous list that contains multiple sub-domains.}

% \begin{lstlisting}[caption={The \lstinline{Yield} LDK, the adaptive version},label={derivedContinuationDsl}]
% implicit def derivedContinuationDsl[Keyword, Domain, Value, KeywordValue](
%   implicit restDsl: Dsl[Keyword, Domain, KeywordValue]
% ): Dsl[Keyword, Domain !! Value, KeywordValue] = {
%   new Dsl[Keyword, Domain !! Value, KeywordValue] {
%     def apply(keyword: Keyword, handler: KeywordValue => Domain !! Value): Domain !! Value = {
%       (continue: Value => Domain) =>
%         restDsl.apply(keyword, { a =>
%           handler(a)(continue)
%         })
%     }
%   }
% }
% \end{lstlisting}

% Therefore, the \lstinline{Yield} LDK can be used in \lstinline{(Stream[String] !! JsonType)} domain as shown in Listing \ref{bobLoggingParserReset}, because the type class \lstinline{Dsl[Yield[String], Stream !! JsonType, Unit]} can be implicitly resolved as \lstinline{derivedContinuationDsl(yieldDsl)}.

% \section{Benchmark}\label{Benchmark}


% \section{\lstinline{Dsl} type class in languages other than Scala}\label{other-language}


% \section{Discussion and Conclusion}\label{Conclusion}

% This paper presents a novel approach to build embedded DSLs in control flow. The approach is based on three assumptions:

% \begin{enumerate}
%   \item The return type is the specific domain of a DSL.
%   \item A DSL feature should be adaptive to various domains.
%   \item Native control flow of the meta-language should be supported in a DSL.
% \end{enumerate}

% By combining of the three assumptions, we defined the concept LDK (Library-Defined Keyword). An LDK is merely an ad-hoc polymorphic delimited continuation, interpreted by a domain-specific type class, as described in Section \ref{Creating library-defined keywords}.

% But what interesting is that an LDK can be considered as a more general version of monadic bind operation as well. The interpreter of an LDK is a triple parametric \lstinline{Dsl} type class (Listing \ref{Dsl}), which contains only one \lstinline{apply} function, whose type signature is \lstinline{(K, (A => D)) => D}, which is exactly as same as monadic bind operation when \lstinline{K} is \lstinline{F[A]} and \lstinline{D} is \lstinline{F[B]}. Thus, the interpreter for \lstinline{Monadic} LDK (See section \ref{Monadic programming}) can be implemented as a trivial forwarder to the bind operation, as shown in Listing \ref{monadDsl}. In contrast, the reverse adapter is quite difficult, if not impossible, to be implemented.

% \begin{lstlisting}[float=htbp,caption={The implementation of interpreter for \lstinline{Monadic} LDK},label={monadDsl}]
% implicit def monadDsl[F[_], A, B](implicit monad: Monad[F]): Dsl[Monadic[F, A], F[B], A] =
%   new Dsl[Monadic[F, A], F[B], A] {
%     def apply(keyword: Monadic[F, A], handler: A => F[B]): F[B] = {
%       monad.bind(keyword.fa)(handler)
%     }
%   }
% \end{lstlisting}

% The benchmarks in Section \ref{Benchmark} demonstrated that our approach of triple parametric polymorphism improves both the extensibility and computational performance, in comparison to ordinary delimited continuations, monads or other direct style DSLs (Table \ref{comparison}).

% \begin{table}[htbp]
%   \begin{tabulary}{\linewidth}{Llll}
%     Direct style DSL & Control flow & Extensibility & Performance \\
%     \hline
%     LDKs provided by \textit{Dsl.scala} & supported & automatically adapted & good \\
%     \hline
%     Scala Async & supported & unsupported & good \\
%     \hline
%     Delimited continuation & supported & unsupported & good \\
%     \hline
%     \texttt{for} comprehension + monad transformer & unsupported & requires manually lifting & not good \\
%     \hline
%     Compiler-defined keywords \texttt{yield}, \texttt{async} and \texttt{await} in C\#, Python or ECMAScript & supported & unsupported & uncomparable \\
%   \end{tabulary}
%   \caption{The comparison of direct style DSLs}
%   \label{comparison}
% \end{table}

% The capacity of LDKs is the superset of both monads and ordinary delimited continuations, thus LDKs can be used in various domains as they can be, including asynchronous or parallel programming, lazy stream generation, collection manipulation, resource management, etc. But unlike monads or ordinary delimited continuations, an LDK user can use multiple LDKs for different domains at once, along with ordinary control flow and ordinary types. No manually lifting is required, just like first-class features.

\clearpage
% Appendix
\appendix

% \printglossary

\begin{acks}
% TODO: acknowledge Marisa Kirisame
\end{acks}

% Bibliography
\bibliography{bibliography}
